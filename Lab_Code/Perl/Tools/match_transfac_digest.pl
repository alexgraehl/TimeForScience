#!/usr/bin/perl -w

# This program processes 'match' output for multiple input fastq sequences. 'match' is the TRANSFAC program for motif finding.
# You give it one "match" output file (which is a super LONG file) and it gives you a tabular file as output.

use strict;  use warnings;  use diagnostics;
use POSIX      qw(ceil floor);
use List::Util qw(max min);
use Getopt::Long;
use Carp; # backtrace on errors. Has the "confess" function. Use this instead of "die" if you want useful information!   

#use File::Basename;

$| = 1; # Always flush text output IMMEDIATELY to the console, don't wait to buffer terminal output! Setting this to zero can cause STDERR and STDOUT to be interleaved in weird ways.

#no warnings 'numeric';
#use Scalar::Util;
#print Scalar::Util::looks_like_number($string), "\n";

sub op($) {
    print STDOUT $_[0];
}

sub tryToLoadModule($) {
    my $x = eval("require $_[0]");
    if ((defined($@) && $@)) {
	warn "We FAILED to load module $_[0]. Skipping this module, but continuing with the program.";
	return 0; # FAILURE
    } else {
	$_[0]->import();
	return 1; # SUCCESS
    }
}

my $SHOULD_USE_COLORS = tryToLoadModule("Term::ANSIColor");
if ($SHOULD_USE_COLORS) { use Term::ANSIColor; }

sub warnPrint($) { chomp($_[0]); warn(safeColor("[WARNING]: " . $_[0] . "", "yellow on_black")); } # regarding "warn": if the string ends with a newline it WON'T print the line number!

sub safeColor($;$) { # one required and one optional argument
    ## Returns colored text, but only if $SHOULD_USE_COLORS is set.
    ## Allows you to totally disable colored printing by just changing $SHOULD_USE_COLORS to 0 at the top of this file
    # Colorstring is OPTIONAL, and can be something like "red on_blue" or "red" or "magenta on_green"
    # Example usage:
    #    *    print STDERR safeColor("This warning message is red on yellow", "red on_yellow");
    my ($message, $color) = @_;
    return (($SHOULD_USE_COLORS && defined($color)) ? (Term::ANSIColor::colored($message, $color) . Term::ANSIColor::color("reset")) : $message);
}

sub printColorStderr($;$) {
    # prints color to STDERR *UNLESS* it is re-directed to a file, in which case NO COLOR IS PRINTED.
    my ($msg, $col) = @_; # Only prints in color if STDERR is to a terminal, NOT if it is redirected to an output file!
    if (! -t STDERR) { $col = undef; } # no coloration if this isn't to a terminal
    print STDERR safeColor($msg, $col);
}

sub printColorStdout($;$) {
    # prints color to STDOUT *UNLESS* it is re-directed to a file, in which case NO COLOR IS PRINTED.
    my ($msg, $col) = @_; # Only prints in color if STDOUT is to a terminal, NOT if it is redirected to an output file!
    if (! -t STDOUT) { $col = undef; } # no coloration if this isn't to a terminal
    print STDOUT safeColor($msg, $col);
}

sub dryNotify(;$) { # one optional argument
    my ($msg) = @_;
    $msg = (defined($msg)) ? $msg : "This was only a dry run, so we skipped executing a command.";
    print STDERR safeColor("[DRY RUN]: $msg\n", "black on_yellow");
}

sub notify($) { # one required argument
    my ($msg) = @_;
    warn safeColor("[DRY RUN]: $msg\n", "cyan on_blue");
}

sub main();
sub quitWithUsageError($) { print($_[0] . "\n"); printUsageAndQuit(); print($_[0] . "\n"); }
sub printUsageAndQuit() { printUsage(); exit(1); }

sub printUsage() {
    print STDOUT <DATA>;
    exit(0);
}

# ==1==
sub main() { # Main program
    $Getopt::Long::passthrough = 1; # ignore arguments we don't recognize in GetOptions, and put them in @ARGV

    my $bestOnly = 0; # if this is set to 1, then we ignore all the different core selections, sequences

    GetOptions("help|?|man" => sub { printUsageAndQuit(); }
	       , "best-only|bestonly|best|best_only!" => \$bestOnly
	) or printUsageAndQuit();
    # print STDERR "hellow\n";
    # print STDERR "Test color!\n";
    my $numUnprocessedArgs = scalar(@ARGV);
    if ($numUnprocessedArgs != 1) {
	quitWithUsageError("Error in arguments! You must send exactly one 'match' formatted file (i.e., files generated by the TRANSFAC tool named 'match') to this program!\n");
    }

    my $fn = $ARGV[0];
    (-e $fn) or die "Could not find specified file '$fn'!";

    my $sid = undef; # "sequence id goes here";

    my %allids = ();
    my %ah     = (); # hash

    my $lineNum = 0;
    while (my $line = <>) {
	chomp $line;
	$lineNum++;
	if ($line =~ /Inspecting sequence ID(.*)/i) {
	    printColorStderr("Gathering data for sequence id '$1'...\n", "green");
	    $sid = $1;
	    if (exists($ah{$sid})) { die "Somehow the sequence ID '$sid' has appeared twice in your input file! Fatal error, quitting now...\n"; }
	    $ah{$sid} = (); # new hash
	    next; # <-- done processing this line!
	}
	next if !defined($sid); # // skip things until we find a sequence ID
	my $z = $line;
	$z =~ s/\s//g; # remove whitespace
	#print $z . "\n";
	my @a = split(/\|/, $z); # the bar character requires wonkiness to split on it: just plain '|' will FAIL!!!

	next if (scalar(@a) <= 1); # if there's no info on this line, skip it!

	if (scalar(@a) < 5) { die "Programming error: 'a' was wrong for line: $z, which had a scalar length of " . scalar(@a) . ".\n";}
	my $motifID     = $a[0];
	my $loc         = $a[1];
	my $coreMatch   = $a[2];
	my $matrixMatch = $a[3];
	my $motif       = $a[4]; # capitalization matters! core is always 5 capital letters
	my $key = $motifID . "|" . ($bestOnly ? "BEST_ONLY" : "$motif"); # append 'BEST_ONLY' if the motifs are collapsed. Otherwise, show the actual motif.
	printColorStderr("Progress report... got the key '$key'...\n", "green");
	if (exists($allids{$key}) && defined($allids{$key})) { 
	    printColorStderr("Discarding an alternative sequence for the motif '$motifID' (only keeping the first one found, which should also be the best one)...\n", "yellow");
	    next; # next please!
	} else {
	    $allids{$key} = 1; # just remember we saw this key!
	    $ah{$sid}{$key} = $z; # save the rest
	}
    }

    my @seqNames = sort(keys(%ah));

    op("MOTIF_NAME");
    foreach my $s (@seqNames) {
	op("\t" . $s);
    }
    op("\n");

    op("## Description: motifs are '|'-delimited. Fields are as follows: 'MATRIX IDENTIFIER' | 'POSITION AND STRAND' | 'CORE MATCH' | 'MATRIX MATCH' | 'SEQUENCE (5-BASE CORE IN CAPITAL LETTERS)'.\n");

    foreach my $motifKey (sort(keys(%allids))) { # iterate over motifs
	op($motifKey); # key, first item on each line
	for my $sk (@seqNames) {
	    my $dat = (exists($ah{$sk}{$motifKey})) ? $ah{$sk}{$motifKey} : ".....";
	    op("\t" . $dat);
	}
	op("\n"); # done with this particular motif
    }
} # end main()


main();


END {
    # Runs after everything else.
    # Makes sure that the terminal text is back to its normal color.
    if ($SHOULD_USE_COLORS) { print STDERR Term::ANSIColor::color("reset"); print STDOUT Term::ANSIColor::color("reset"); }
}

exit(0);
# ====

__DATA__

match_transfac_digest.pl  FILENAME

by Alex Williams, 2014.

This program processes 'match' output for multiple input fastq sequences. 'match' is the TRANSFAC program for motif finding.

You give it one "match" output file (which is a super LONG file) and it gives you a tabular file as output.

The output of "match" looks something like this. It is always '|'-deimited:

      MATRIX                    POSITION      CORE     MATRIX   SEQUENCE
      IDENTIFIER                & STRAND      MATCH    MATCH    ........  
  24  F$HSF_01               |     3686 (-) |  1.000 |  1.000 | GTTCT
  25  F$MATALPHA2_01         |     1238 (+) |  1.000 |  0.980 | gCATGTgaat
  26  V$P300_01              |     1878 (-) |  1.000 |  0.995 | ctcccACTCCctaa
  27  V$P300_01              |     3225 (+) |  1.000 |  0.986 | ctggGGAGTggctg
  28  V$CREB_01              |     1604 (-) |  1.000 |  0.946 | aaaCGTCA
  29  V$CREBP1_01            |     2217 (+) |  0.766 |  0.849 | TTAGGtaa
  30  V$CREBP1_01            |     2217 (-) |  0.831 |  0.891 | ttaGGTAA

If you have multiple fasta input files, you PROBABLY want to see all the data in the ouptut together in one tabular file,
instead of a very "tall" regular file.

See the examples below for more information.

CAVEATS:

 none

OPTIONS:

 --bestonly: If this is specified, then instead of reporting the different sequences (e.g., cccccG and cccccA), we just report
             the OVERALL motif, which basically means we only report the BEST match per motif.
             This reduces output file size (and number of rows) significantly, but also discards some data! Use with caution.

EXAMPLES:

match_digest.pl --help
  Displays this help

match_digest.pl THE_MOTIF_OUTPUT_FILE.OUT

    Aggregates the data in "THE_MOTIF_FILE.OUT" and outputs it in a table.

KNOWN BUGS:

  None known.

TO DO:

    None yet.

--------------
