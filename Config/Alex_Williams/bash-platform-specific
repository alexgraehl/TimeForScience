# -*-Sh-*- <-- tells emacs what kind of syntax highlighting to use

## SSH_CLIENT and SSH2_CLIENT are set automatically by SSH if you are connected to a machine by SSH

if [[ $BASH_PLATFORM_SPECIFIC_FILE_IS_ALREADY_INCLUDED ]] ; then
    return; ## Return early--don't include this file multiple times.
fi

if [[ -z $SSH_CLIENT && -z $SSH2_CLIENT ]] ; then
    is_sshing=0 ## We aren't connected to any other server...
else
    is_sshing=1 ## We are connected via SSH or SSH2...
fi


if [[ $is_sshing -eq 1 ]] ; then
    CONN=ssh
elif [[ -z $SESS_SRC ]] ; then
    CONN=lcl
elif [[ $SESS_SRC == "(:0.0)"]] || [[$SESS_SRC == "" ]] ; then
    CONN=lcl
else
    CONN=tel
fi


case "$TERM" in
    xterm-color|xterm-256color)
	color_prompt=1;
	;;
    *)
	color_prompt=0; # <-- Non-color terminal
	;;
esac

case "$OSTYPE" in
    darwin10.0)
	isMac=1
	;;
    *)
	isMac=0
	;;
esac

if [[ $HOSTNAME == "Guinea-Beast.local" ]]; then
    isAGWHomeMachine=1
else
    isAGWHomeMachine=0
fi


## The \[ and \] around the colors tell "readline" that these sequences
## are NOT printed to the screen. This fixes some problems with wrapping.
if [[ $color_prompt -eq 1 ]] ; then
    color_prefix="\033" ## <-- \033 works everywhere. \e works on Linux
    a_echo_color="${color_prefix}[1;32m" ## green  ## can also be: 1;33 ## was [3;40m before
    a_status_color="${color_prefix}[1;33m"
    a_warning_color="${color_prefix}[1;31m"
    a_end_color="${color_prefix}[m"
else
    color_prefix='' # Sadly, we do not have color on this terminal.
    a_echo_color=''
    a_status_color=''
    a_warning_color=''
    a_end_color=''
fi


if [[ 'Alex' == $USER ]] ; then
    ## Change 'Alex' to 'alexgw', since that's what all the remote servers at UCSF expect
    UCSF_USER='alexgw'
else
    UCSF_USER=$USER
fi



BASH_PLATFORM_SPECIFIC_FILE_IS_ALREADY_INCLUDED=1
