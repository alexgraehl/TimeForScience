# -*-Sh-*- <-- tells emacs what kind of syntax highlighting to use

# ======================
# "Unofficial bash strict mode: " #!/bin/bash
# set -euo pipefail
# IFS=$'\n\t'
# ======================

if [ -f $HOME/TimeForScience/Config/Alex_Williams/bash-platform-specific ]; then
    source $HOME/TimeForScience/Config/Alex_Williams/bash-platform-specific
fi

if [ -f ${BINF_CORE_WORK_DIR}/Common/Code/alexgw/aliases-server-config ]; then
    source ${BINF_CORE_WORK_DIR}/Common/Code/alexgw/aliases-server-config
elif [ -f ~/.aliases-server-config ]; then
    source ~/.aliases-server-config # for machines that do not have the /work repository, you can just manually transfer the file over like so!
    echo "Note: loading the .aliases-server-config MANUALLY from the home directory."
else
    echo "Note: no .aliases-server-config was found. SSH commands and tmux coloring may fail. You may want to MANUALLY copy this file over from another machine. Copy the other machine's ${BINF_CORE_WORK_DIR}/Common/Code/alexgw/aliases-server-config to this local machine's ~/.aliases-server-config ."
fi

if [[ "$USER" == "alexgw" ]]; then
    #echo "Fixing my git status on various accounts..."
    #git config --global user.name "alexgraehl" ; git config --global user.email "alexgraehl@users.noreply.github.com"

    ## =====================================================================================================================
    ## ====== SAFER 'rm' COMMANDS --only applies to the user alexgw, unless you change the line above!  ====================
    ## Below: aliases the command "rm" to actually run the script "trash.pl," which moves files to a trash directory in /tmp.
    ## They can be recovered by just copying them back.
    ## Use the "checktrash" command to find the trash directory if you forget where it is.
    #alias rm='/home/${USER}/trash.pl'
    
    ## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
    alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'
    alias emptytrash='mkdir -p /tmp/${USER}/Trash/ && /bin/rm -rfv /tmp/${USER}/Trash/ && echo "Emptied the trash directory (/tmp/${USER}/Trash)" ;'
    ## ====== SAFER 'rm' COMMANDS ====================
    ## ===============================================================
    alias rm='trash.pl' ## <-- Note that the "real" rm can still always be invoked by '/bin/rm'
fi

# git config --global user.name "alexgraehl" ; git config --global user.email "alexgraehl@users.noreply.github.com"

echo -e "${a_echo_color}>>> BASH: Loading bash-aliases...${a_end_color}"
#echo $GIT_COMMITTER_EMAIL
# echo $GIT_AUTHOR_EMAIL # not important if you set the other thing

## Searches both the R source and the current directory (and any subdirectories!)
## Note that it only looks for files with a ".R" ending!!!!!!!
if [[ -n "$isMac" ]] ; then
    ## It *is* a mac!
    function ff {
	`which grep` --color=always --ignore-case --recursive --extended-regexp --exclude="Mothballed" --exclude=".hg" --exclude="CVS" --exclude="[bB]ackup*" --exclude="Annotation*.txt" \
	    "$@" \
	    "${BINF_CORE_WORK_DIR}/Common/Code/R_Binf_Core" \
	    "${BINF_CORE_WORK_DIR}/Common/Code/ProjectCode" \
	    "${HOME}/TimeForScience" \
	    ./
    }

    alias zcat='gunzip -c' ## On the Mac, "zcat" likes to append '.Z' to filenames. Super annoying.
else
    ## Not the mac!
    function ff {     ## Annoyingly, grep is different between mac/unix
	grep --color=always -T \
	    --ignore-case \
	    --recursive \
	    --extended-regexp \
	    --line-number --with-filename \
	    --exclude-dir="Mothballed" --exclude-dir="\.hg" --exclude-dir="CVS" --exclude-dir="[bB]ackup*" \
	    --binary-files=without-match \
	    --include=*.R --include=*.pl --include=*.py \
	    "$@" \
	    "${BINF_CORE_WORK_DIR}/Common/Code/R_Binf_Core" \
	    "${BINF_CORE_WORK_DIR}/Common/Code/ProjectCode" \
	    "${HOME}/TimeForScience"
    }
fi

function hunt { # cd into a directory with a script
    echo "Hunting the most dangerous game of all: cd-ing the directory where \"$(basename $(which $1))\" lives..."
    THEDIR=$(dirname $(which $1 | head -n 1))
    cd "$THEDIR"
    echo "Moved into directory <$THEDIR>."
}

function cto { # instead of CD to a file, CD directly to a file's directory, since naturally you can't actually CD to a file
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass EXACTLY ONE filename or directory name into this function!"; return; fi
    if [[ -d "$1" ]] ; then cd "$1" ; return 0; fi # it's already a directory, change to it!
    TO=$(dirname "$1")
    cd "$TO"
}

function witch { # Shows the versions for all on-your-path verisons of software.
    # Takes TWO required arguments
    # Example:   witch emacs --version
    # Or:        witch java -version   (some programs are dumb and do not support --version)
    # Or:        witch something -V
    if [[ "$2" == "" ]]; then
	echo "ERR: You need to specify a program to check the versions of. Example:  witch emacs --version ."
	return 1;
    fi
    if [[ "$2" == "" ]]; then
	echo "ERR: You need to specify a version-obtaining-argument like '--version' to the 'witch' command";
	echo "     Example:   witch emacs --version   or java -version (Java doesn't support --version)";
	return 1;
    fi
    for f in $(which -a "$1"); do echo -en "\n${a_echo_color}$f${a_end_color} --> "; $f "$2" | head -n 3; done; echo ""
}

function delve {
    ## Finds, in any subdirectories, any files that have a name that matches the input text. Sort of like a poor man's "locate"
    find ./ -iname "*$@*"
}

function vncnau { # Forwards the ports from this machine to the localhost
    echo "Now forwarding port 590$* from $BN_HOSTNAME... you should launch your VNC client now and connect to localhost:$*"
    ssh -L 590$*:localhost:590$* -p 22 alexgw@${BN_IP} -N
}

function vnccat { # Forwards the ports from this machine to the localhost
    echo "Now forwarding port 590$* from $BC_HOSTNAME ... you should launch your VNC client now and connect to localhost:$*"
    ssh -L 590$*:localhost:590$* -p 22 alexgw@${BC_IP} -N
}

function vncstart {
    vncserver -geometry 1600x1000 -depth 16
}

BRACKET_OPEN='{'
PAREN_OPEN='('
NL="\$'\\n'" # newline!
alias cheat="echo \
\">> Echo emoji to terminal: example: a snake is echo $'\xF0\x9F\x90\x8D' (See http://apps.timwhitlock.info/emoji/tables/unicode) \" ${NL}\
\">> Safari: Disable page previews: defaults write com.apple.Safari DebugSnapshotsUpdatePolicy -int 2 \" ${NL}\
\">> Unzip files into SUBDIRECTORIES always: ls *.zip|awk -F'.zip' '{print \\\"unzip \\\"\\\$0\\\" -d \\\"\\\$1}'|sh  \" ${NL}\
\">> ZIP on Mac without the dot files: zip -r -X out.zip input_directory_here    -x \\\"*.DS_Store\\\" \" ${NL}\
\">> RAM / Filesystem: clear out disk cache, recover RAM: purge \" ${NL}\
\">> Mac: what program is using a disk / preventing eject: sudo lsof -xf +d /Volumes/THEVOL \" ${NL}\
\">> Mac disk: specific file I/O: fs_usage <programname> \" ${NL}\
\">> Mac disk: filesystem I/O:    fs_usage -w | grep -v '0\\.0'  \" ${NL}\
\">> Mac set startup disk: sudo bless -mount /Volumes/YOURDISK -setBoot \" ${NL}\
\">> Mac: show weird file flags: ls -l -@ \" ${NL}\
\">> Mac Time Machine: exclude / check: tmutil isexcluded / tmutil addexclusion (-p) PATH \" ${NL}\
\">> Mac Time Machine: delete backups: tmutil delete /Volumes/DISK/Backups.backupdb/COMPNAME/ \" ${NL}\
\">> Mac: recursively clear worthless quarantine flags: xattr -r -d com.apple.quarantine FILENAME \" ${NL}\
\">> Mac: delete impossible-to-delete files find FILE -flags schg -exec chflags noschg {} \\; \" ${NL}\
\">> Mac: show library: chflags nohidden ~/Library/ \" ${NL}\
\">> Mac: batch change modification time: find . -print0 | xargs -0 SetFile -d '12/31/2012 12:00:00 PM' \" ${NL}\
\">> Mac: No quarantine warn  : defaults write com.apple.LaunchServices LSQuarantine -bool NO \" ${NL}\
\">> Mac: check code signing: codesign -vvv /Applications/iTunes.app \" ${NL}\
\">> Mac: No .DS_Store servers: defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool YES \" ${NL}\
\">> Mac: Select in QuickLook (buggy!): defaults write com.apple.finder QLEnableTextSelection -bool YES \" ${NL}\
\">> Mac: No smooth scroll: defaults write -g NSScrollAnimationEnabled -bool NO \" ${NL}\
\">> Mac / cron : edit crontab cron.tab with emacs: env EDITOR=emacs crontab -e \" ${NL}\
\">> Image SIPS: PNG -> JPEG: mkdir outjpegs; sips -s format jpeg *.png --out outjpegs \" ${NL}\
\">> Imagemagick convert multi-page pdf: for a in \\\$(seq 90); do echo \\\"Converting page \\\$a...\\\"; convert -quality 80 your.pdf[\\\$a] OUT_page_\\\$a.jpg ; done  \" ${NL}\
\">> Imagemagick convert recursive: find ./ -name \\\"*.jp*\\\" -print0 | xargs -0 -I{} convert -resize 1024x768 -quality 85 {} {}  # or resize 50%\" ${NL}\
\">> Imagemagick convert PDF -> PNG w/antialias and downsample: convert -verbose -density 144 in.pdf +antialias out.png  Note that argument order is very important and may not be correct here. It is also very slow..\" ${NL}\
\">> MP3: Convert m4a/ogg->mp3 for name in *.ogg; do ffmpeg -i \\\"\\\$name\\\" -ab 256k -map_metadata 0:s:0 \\\"Converted_\\\${name/.ogg/.mp3}\\\"; done; \" ${NL}\
\" \" ${NL}\
\">> Check directories for differences (by modification time): ionice -c3 rsync --dry-run --delete -vr /dirA /dirB \" ${NL}\
\">> Find all .R files in a directory:   find ./ -name \\\"*.R\\\" -exec ls \'{}\' \\\; \" ${NL}\
\">> DIFF directories:   diff -rq DIR1 DIR2 \" ${NL}\
\" \" ${NL}\
\">> BASH script header (3 lines): #!/bin/bash -u   set -e   set -o pipefail \" ${NL}\
\">> BASH: Literal tab: \$'\\t' (example: join -t \$'\\t' to join on tabs) or \\\$(echo -en '\\t') . In MAKE: printf '\\t' \" ${NL}\
\">> SH  : Get directory of this script (fails if last item is a symlink): DIR_OF_SCRIPT=\\\"\\\$( cd \\\"\\\$(dirname \\\"\\\${BASH_SOURCE[0]}\\\" )\\\" && pwd )\\\" \" ${NL}\
\">> PYTHON debug a crashing program: python -m pdb YOURPROG --yourargs . 'c' continues execution, 's' steps. \" ${NL}\
\">> PYTHON debug a crashing program: Put this in the code verbatim to properly enter the debugger at a specific point:  import pdb; pdb.set_trace() \" ${NL}\
\" \" ${NL}\
\">> R: Save copy of figure as pdf: dev.copy2pdf() \" ${NL}\
\">> R: Prevent blank page in PDF: pdf(..., onefile=FALSE) \" ${NL}\
\">> R: Aggregate rows / average rows with same name (mean): mAGG <- t(sapply(by(MAT,rownames(MAT),colMeans),identity)) \" ${NL}\
\">> R: Read bzip/gz file:  x <- read.table(bzfile(\\\"name.bz2\\\") or gzfile(...) \" ${NL}\
\">> R: Read from stdin:    x <- read.table(pipe(\\\"cat something name.bz2 | bunzip2\\\") \" ${NL}\
\">> R: Pick CRAN mirror, no GUI popup (install.packages): chooseCRANmirror(graphics=F) \" ${NL}\
\">> R: Install package from source:  R CMD INSTALL packagename.tar.gz  (or use biocLite(...) or install.packages(...)) \" ${NL}\
\">> R: sessionInfo(): show packages. ls('package:something') shows details. '.libPaths()' shows lib dirs. \" ${NL}\
\">> R: traceback() - to properly debug. Also: options(error=recover()) \" ${NL}\
\">> R: t.test failing? Use tryCatch: tryCatch(something, error=function() { return('NA'); }); \" ${NL}\
\">> R: Need to un-list things? Use unlist! \" ${NL}\
\">> R: Perpendicular axis labels: las=2 (1=horiz, 3=vertical) \" ${NL}\
\">> R: draw beyond graph region: par(xpd=T/F/NA) \" ${NL}\
\">> R: square plot: par(pty='s') \" ${NL}\
\">> R: figure out attributes of a variable: attr(x, 'theAttribute'); Works even when names()/attributes() does not! \" ${NL}\
\">> R: inspect object: str(...) \" ${NL}\
\">> R: totally blank plot: plot(c(0,1),c(0,1),ann=F,bty='n',type='n',xaxt='n',yaxt='n') \" ${NL}\
\">> R: cut things into bins, like a histogram: cut(...) \" ${NL}\
\">> R: factor -> Integers: unclass(...) \" ${NL}\
\">> R: Perpendicular axis: par(las=2) (1 = horiz, 3 = vertical) \" ${NL}\
\">> R: Draw BEYOND the axes / plot region: par(xpd=...) \" ${NL}\
\">> R: Show package contents: ls('package:some_package_name_here') \" ${NL}\
\">> R: Show versions of installed packages: sessionInfo(...) \" ${NL}\
\">> R: Collapse a list down to a basic vector: unlist(...) \" ${NL}\
\">> R: Resize terminal width / columns: options(width=Sys.getenv(\\\"COLUMNS\\\")) \" ${NL}\
\">> R: write.table(DATA, file='x.txt', row.names=T, col.names=NA, sep='\t', quote=F)  \" ${NL}\
\">> R: make libraries usable by non-root users: sudo chmod -R a+r /usr/local/lib/R ; sudo find /usr/local/lib/R -type d | sudo xargs chmod a+x \" ${NL}\
\">> R: update all installed packages: update.packages(ask=FALSE, checkBuilt=TRUE) \" ${NL}\
\">> R: read from clipboard: y=data.matrix(read.delim(pipe(\\\"pbpaste\\\"))); \" ${NL}\
\" \" ${NL}\
\">> GZIP: verify files: for f in **/*.gz; do gunzip --test -v \\\$f ; done; \" ${NL}\
\">> Text: wrap lines at 80 chars, preserving/ignoring word boundaries: fold -w 80 -s text.txt (omit -s to cut words) \" ${NL}\
\">> Shell/bash: Redirect stdout/stderr separately: CMD > out.txt 2> err.txt \" ${NL}\
\">> Shell/bash: Pipe stderr (and stdout too): CMD 2>&1 | less -S \" ${NL}\
\">> Shell/bash: Modify variable: newV=\\\$(sed -e's/a/1/; s/b/2/; s/c/3/' <<< \\\$oldV) \" ${NL}\
\">> Shell/bash: Script run with ionice:  ionice -c3 -p\\\$\\\$ (top line of a /bin/sh script) \" ${NL}\
\">> Shell/bash: Rename files with parent directory in filename for f in DIRS*/file.whatever; do echo \\\$f \\\$(dirname \\\$f)/\\\$(dirname \\\$f).\\\$(basename \\\$f).whatever ; done \" ${NL}\
\">> Shell/bash: Rename files to have unique names: for f in **/*fastqc.html; do /bin/cp \\\$f DESTINATION_DIR/\\\$(md5sum \\\$f | cut -d ' ' -f 1).\\\$(basename \\\$f); done \" ${NL}\
\" \" ${NL}\
\">> MD5 verify: md5sum -c md5*.txt. Checksum must be 1st col, then 2 spaces, then filename. If checksum is 2nd: cat md5*.txt | awk '{print \\\$2\\\"  \\\"\\\$1}' | md5sum -c \" ${NL}\
\">> HEX HEXDUMP: View individual bytes of a file in hex form: hexdump -C FILENAME \" ${NL}\
\">> AWK: sum numbers in column 1 of a file: cat FILE | awk '{ sum+=\\\$1} END {print sum}'\" ${NL}\
\">> HG: Mercurial: restore accidentally-locally-deleted file from repo: hg revert FILENAME \" ${NL}\
\">> HG: Mercurial: revert to previous version: hg revert FILENAME -r-2 (or -r-3 for two versions ago, etc) \" ${NL}\
\">> HG: Mercurial: show diff from last version: hg diff -c -1 (or -2, -3, etc.) \" ${NL}\
\">> HG: Mercurial: <push creates new remote heads> is fixed by doing hg pull first! \" ${NL}\
\">> GIT only get the last 1 revision (faster): git clone --depth=1 https://your-site-here/something.git \" ${NL}\
\">> GIT discard ALL local changes: git reset --hard origin/master \" ${NL}\
\">> GIT fix an HTTP repo to SSH: git remote set-url origin git@github.com:RepoNameHere/ProjName.git \" ${NL}\
\">> GIT see old version of file (example: ~4 = 4 revisons ago): git show HEAD~4:./some_file.txt \" ${NL}\
\">> TERM: Get terminal width/height: tput cols  or  tput lines \" ${NL}\
\">> BACKUPS: Check for changed files of a certain name: grep -E '>f.' /it/backup/log/*.log | grep YOURNAME \" ${NL}\
\">> UNIX / FILE: Add filename to top of (copy of) files. for f in FILES*; do echo \\\$f | cat - $f > NEW_\\\$f ; done \" ${NL}\
\">>           ...or if you will later paste/join those: for f in SPLIT*.diff; do echo \\\$f | cat - \\\$f | table-no-ragged.py - > NEW_\\\$f; done \" ${NL}\
\">> UNIX: convert RELATIVE symlinks to ABSOLUTE PATHS: for fff in *; do FULL=\\\$(readlink -f \\\$fff); ln -sf \\\$FULL \\\$fff ; done \" ${NL}\
\">> UNIX: double-dereference symlinks, showing their final targets: find -L . -type f -exec readlink -f {} \\\; \" ${NL}\
\">> UNIX: double-dereference symlinks, showing their final targets: for f in * ; do echo -e \\\$f\\\"\\t\\\"\\\$(readlink -f \\\$f); done   \" ${NL}\
\">> UNIX: delete ORPHANED symlinks: find /path/to/search -xtype l -delete ; \" ${NL}\
\">> UNIX: total file size for files with a certain extension (Here, jpg): find . -type f -iname '*.jpg' -print0 | du -ch --files0-from=- \" ${NL}\
\">> UNIX: list files w/modified time MORE THAN one week ago: find . -mtime +7 \" ${NL}\
\">> UNIX: list files w/modified time LESS THAN one week ago: find . -mtime -7 \" ${NL}\
\">> UNIX: list files w/modified time two days ago: find . -mtime 2 \" ${NL}\
\">> UNIX: list files w/modified time between 6 and 9 minutes ago: find . -mmin +5 -mmin -10 \" ${NL}\
\">> UNIX: list ONLY dot files, no .. or up a directory: ls -l .??* \" ${NL}\
\">> UNIX: set up symlinks from Mercurial/TimeForScience: ln -sfn ~/TimeForScience/Config/Alex_Williams/.??* ~/ \" ${NL}\
\">> UNIX: symlink executables: for f in \\\$(find PATH -maxdepth 1 -perm -111 -type f); do ln -s \\\$f ./; done \" ${NL}\
\">> UNIX: upgrade: sudo aptitude update && sudo aptitude safe-upgrade <-- more assertive than apt-get upgrade.\" ${NL}\
\">> UNIX: IO nice (low-priority): ionice -c2 -n7 -pPROCID <-- -n7: lowest non-idle priority. PROCID is the PID.\" ${NL}\
\">> UNIX: IO nice (lowest-priority): ionice -c3 -pPROCID  <-- -c3: IDLE priority; doesn't slow anyone else down.\" ${NL}\
\">> UNIX: IO nice for a user \\\$THEUSER: SSS=\\\$(ps -fu \\\$THEUSER | perl -pe 's/[ ]+/\t/g' | cut -f 2 | tail -n +2); for pid in \\\$SSS ; do echo 'PID' \\\$pid; sudo ionice -c3 -p \\\$pid ; sudo renice +10 -p \\\$pid; done\" ${NL}\
\">> UNIX: Find zombie processes: ps aux | awk '{ print \\\$8 \\\" \\\" \\\$2 }' | grep -w Z \" ${NL}\
\">> UNIX: Check Linux version: cat /etc/*-release \" ${NL}\
\">> UNIX: Set system time on Ubuntu: sudo ntpdate-debian \" ${NL}\
\">> UNIX: Rsync transfer files: rsync --dry-run -R -havz --progress --stats --bwlimit=999999 LOCALFILES USER@REMOTE.COM:/path/to/  \" ${NL}\
\">> UNIX: Password FTP command line Xfer: wget -r ftp://USERNAME:password@ftp.some.site.com/Somefiles \" ${NL}\
\">> UNIX/WGET/TRICKLE: Rate limit any command to 500kbps (-d = down, -u = up): sudo trickle -d 500 -u 500 ncftp 'your_ftp_site_here' \" ${NL}\
\">> UNIX: See why Ubuntu wants to restart:  cat /var/run/reboot-required.pkgs \" ${NL}\
\">> UNIX/TOP/USAGE/HTOP: CPU usage by user: top -b -n 1 -u \\\$USER | awk 'NR>7 { sum += \\\$9; } END { print sum; }' \" ${NL}\
\">> QSTAT/QSUB/QRUN/QUEUE/TORQUE: for j in \\\$${PAREN_OPEN}qstat -a | grep 'YOURNAME' | cut -d '.' -f 1); do echo \\\"qdel \\\$j...\\\"; qdel \\\$j ; done \" ${NL}\
\">> QSTAT/QSUB/QRUN/QUEUE/TORQUE: restart torque: sudo service pbs_sched stop ; sudo service pbs_mom stop ; sudo service pbs_server stop ; sudo /bin/rm /var/lock/subsys/pbs_server ; sudo service pbs_sched start ; sudo service pbs_mom start ; sudo service pbs_server start ; qstat \" ${NL}\
\">> QSTAT/QSUB/QRUN/QUEUE/TORQUE: info on the queue: qstat -Qf or qstat -B more details \" ${NL}\
\">> QSTAT/QSUB/QRUN/QUEUE/TORQUE: qrun MULTIPLE jobs in a range: for f in \\\$(seq 119905 119919); do sudo \\\$(which qrun) \\\$f; done \" ${NL}\
\">> UNIX / DPKG / APT-GET: dpkg / apt-get woes? Try manually editing /var/lib/dpkg/info/YOURPACKAGE . Be careful! \" ${NL}\
\">> UNIX / DPKG / APT-GET: Check the version of an apt-get installed package:   dpkg -s <packagename>  OR   dpkg -l | grep -i <search_string> \" ${NL}\
\">> UNIX / YUM / RPM install: (this NEVER works, but): rpm -Uvh your.rpm . Does NOT handle dependencies.\" ${NL}\
\">> UNIX / APTITUTDE: sudo aptitude update && sudo aptitude safe-upgrade <-- more assertive than apt-get upgrade.\" ${NL}\
\">> UNIX / APT-GET: upgrade only EXISTING packages matching wildcard pattern: apt-get install --only-upgrade 'r-cran*' \" ${NL}\
\">> UNIX / APT-GET: Fix 'NO_PUBKEY *SOMEKEY*' in APT: gpg --keyserver subkeys.pgp.net --recv *SOMEKEY* ; gpg --export --armor *SOMEKEY* | sudo apt-key add - \" ${NL}\
\">> SSH without loading bashrc or bash_profile: ssh -t user@server bash --norc --noprofile \" ${NL}\
\">> SSH Passphraseless: Client: ssh-keygen -t rsa ; Append client ~/.ssh/id_rsa.pub   to server ~/.ssh/authorized_keys \" ${NL}\
\" \" ${NL}\
\">> ZIP: Zip a folder: zip -r ARCHIVENAME FOLDER \" ${NL}\
\">> BASH: Foreach/rename: for f in \\\$${PAREN_OPEN}ls); do echo \\\$f will become \\\$${BRACKET_OPEN}f/.txt/.newending} ; done \" ${NL}\
\">> BASH: redirect STDERR & STDOUT both to console and to a file: THECMD 2>&1 | tee --append LOGFILE\" ${NL}\
\">> BASH: See a function definition: type FUNCTIONNAME \" ${NL}\
\">> BASH: Change tab width in bash:  setterm -regtabs 16 (16 = huge!) \" ${NL}\
\">> BASH: Expand tabs / tab width: something | expand -t 32 \" ${NL}\
\">> Gnu parallel: works like xargs, but works with files with spaces, by default. \" ${NL}\
\">> XARGS/FIND: find . -name SOMEFILE -print0 | xargs -0 -I {} sh -c \\\"echo {}; thing {} | piped here | wc -l\\\"  \" ${NL}\
\">> XARGS/FIND: bzip all the bed/diff/count files that you can find: find . -type f \( -iname \\\"*.bed\\\" -o -iname \\\"*_tracking\\\" -o -iname \\\"*.diff\\\" -o -iname \\\"*.moa\\\" -o -iname \\\"*.fasta\\\" -o -iname \\\".fa\\\" -o -iname \\\"*.bed.count\\\" \) -print0 | xargs -0 bzip2 \" ${NL}\
\">> CHMOD Make files readable, directories r+x (print0/-0 makes filenames with spaces work): sudo chmod -R a+r ./ ; sudo find ./ -type d -print0 | sudo xargs -0 chmod a+x   (this is the command 'sudoshowoff')\" ${NL}\
\">> GNU FIND and DELETE a file (dangerous): find . -name SOMEFILE -delete \" ${NL}\
\">> UNIX/Perl fast sort with ONE header line: cat FILE | perl -e 'print scalar (<>); print sort <>' > OUTFILE \" ${NL}\
\">> Perl: REGEXP multi-line search/replace: perl -00pe 's{thing1}{thing2}gxms' THE_FILE  <-- s lets '.' match newlines\; m makes ^ and \\\$ work \" ${NL}\
\">> Perl/web: Chrome web form non-breaking space (ASCII 160) is [\\xA0] (or 'use feature qw(unicode_strings);') \" ${NL}\
\">> Perl: CPAN invocation: sudo perl -MCPAN -e shell \" ${NL}\
\">> Perl: CPAN upgrade all WITHOUT prompting: PERL_MM_USE_DEFAULT=1 && sudo perl -MCPAN -e shell >> then o conf build_requires_install_policy yes  ; o conf prerequisites_policy 'follow'  ; o conf commit ;  upgrade /(.\\*)/\\\" \" ${NL}\
\">> Perl: Backreferences/does something show up twice on a line: perl -n -e 'print ((\\\$_ =~ /\b(Something\d+)\s.\g1/) ? qq{match: \\\$1\\n} : qq{Nope\\n});' \" ${NL}\
\">> EMACS: insert newline in search-and-replace:  Ctrl-Q Ctrl-J \" ${NL}\
\">> EMACS: install new packages: list-packages \" ${NL}\
\">> EMACS: show variable: describe-variable \" ${NL}\
\" \" ${NL}\
\">> RNASEQ SAM --> BAM:  samtools view -bS in.sam > out.bam \" ${NL}\
\">> RNASEQ BAM --> SAM:  samtools view -h  in.bam > out.sam \" ${NL}\
\">> RNASEQ samtools view first read of pair only:  samtools view -f  64 file.bam \" ${NL}\
\">> RNASEQ samtools view second read of pair only: samtools view -f 128 file.bam \" ${NL}\
\">> RNASEQ sorting and setting the 'sorted' flag:  java -Xmx2g  -jar SortSam.jar INPUT=in.sam SORT_ORDER=coordinate OUTPUT=out_sorted.sam \" ${NL}\
\">> RNASEQ View BAM header: samtools view -H  in.bam \" ${NL}\
\">> RNASEQ Merge BAM files in subdirectories: for f in * ; do samtools merge \\\${f}_merged.bam \\\$f/*.bam; done \" ${NL}\
\">> RNASEQ remove non-primary and non-aligned reads: samtools view -b -F 0x104 in.bam > mapped_primary.bam \" ${NL}\
\">> RNASEQ count primary (0x100) mapped (0x4) reads: samtools view -c -F 0x104 in.bam > COUNT.txt\" ${NL}\
\">> RNASEQ Count frequencies of first 5 bases of a SAM file: cut -f 10 theFile.sam | cut -c 1-5 | sort | uniq -c \" ${NL}\
\">> RNASEQ TOPHAT/rename TEST: for f in *; do echo \\\${f}/accepted_hits.bam \\\${f}/accepted_hits_\\\${f}.bam ; done \" ${NL}\
\">> RNASEQ TOPHAT/rename RUN : for f in *; do   mv \\\${f}/accepted_hits.bam \\\${f}/accepted_hits_\\\${f}.bam ; done \" ${NL}\
\">> RNASEQ: Truncate a fastq file to length 19 without using fastx-trimmer: awk 'NR % 2 == 0 { \\\$0=substr(\\\$0,1,19)} {print}' \" ${NL}\
\">> DNA reverse-complement: perl -e '\\\$x = qq{AAAA_SEQUENCE_GGGG_TT_CC}; \\\$_ = scalar(reverse(\\\$x)); tr/ACGT/TGCA/; print \\\$_;' \" ${NL}\
\">> APACHE error log: sudo less -S /var/log/apache2/error.log \" ${NL}\
\">> Mac OS X Dictionary: /usr/share/dict/words \" ${NL}\
\">> Mac OS X why isn't the screensaver working: pmset -g (see 'sleep' in there), then pmset -g assertions \" ${NL}\
\">> Mac OS X Image type convert: mkdir -p PNGS_TO_JPEG; sips -s format jpeg *.png --out PNGS_TO_JPEG \" ${NL}\
\">> COPROC: coproc: re-run a command every 19 seconds: for i in {1..50} ; do coproc { ls >> myfile.tmp ; } ; sleep 19; kill \\\$COPROC_PID ; sleep 2; done \" ${NL}\
\">> LINES: RANDOM subset (0.5 = 50%, 0.1 = 10%, etc):  perl -ne 'print if (rand() < 0.5);' theFile.txt \" ${NL}\
\">> LINES: REPEATABLE RANDOM subset: perl -e 'srand(123456); while(<>){ print if (rand() < 0.5);}' theFile.txt \" ${NL}\
\">> LINES: Semi-random FASTA records (2 lines at a time): perl -e 'my \\\$total=0; my \\\$MAX=3; srand(); while(<>){ if (rand()<0.01) { print \\\$_; my \\\$nextLine=<>; print \\\$nextLine; \\\$total++; exit(0) if (\\\$total>=\\\$MAX); } }' \" ${NL}\
\">> LINES: Range from N to M, inclusive (starts at 1):  sed -n N,Mp INPUTFILE  or  for a HUGE file: sed -n '(N+1)q;N,Mp' <-- quit on line (N+1) \" ${NL}\
\">> LINES: Every Xth, starting with line Y (starts at 1, not 0): awk 'NR%X==Y' FILE \" ${NL}\
\">> LINES/AWK: Count num columns in file: awk -F '\t' '{print NF}' \" ${NL}\
\">> LINES based on perl expr: perl -e '\\\$n = 0; while(<>) { if (\\\$n%2 == 0) { print \\\$_; }; \\\$n++; }' \" ${NL}\
\">> LINES Count chars on each line: cat FILENAME | awk '{print length(\\\$0)}' \" ${NL}\
\">> AWK: Get only FIRST line with a unique occurrence in column 1. Does not require sorting: cat FILE | awk -F'\\t' '!_[\\\$1]++' (assumes separator is tab) \" ${NL}\
\">> GREP Count occurrences of a match per line: cat FILE | grep -o -n SEARCHTERM | cut -d : -f 1 | uniq -c \" ${NL}\
"

# Shell navigation / commands

#pushd() { builtin pushd "$@" > /dev/null; } ## <-- make it so that pushd doesn't print the stack every single time

#hasExa=agw_cmd_exists "exa"

#if [[ "$hasExa" && "$isMac" ]]; then # check for 'exa' -- the 'ls' replacement, but only on the Mac---it's slow on Rigel!

if agw_cmd_exists "exa" && [ "$isMac" == "1" ] ; then
    alias ls='exa'
    alias ll='exa -l -a'
    alias lmac='exa'
else
    if [[ "$color_prompt" && "$isMac" ]]; then
	AGW_LS_OPT=' -F -G ' #-@ ' ## Mac: Color option is -G. Also, on a Mac, show the extended attributes (-@)
    elif [[ "$color_prompt" && (-z "$isMac") ]]; then
	AGW_LS_OPT=' --indicator-style=slash --color=auto ' ## Ubuntu: color is --color=auto
    else
	AGW_LS_OPT=''
    fi

    if [[ "$isMac" ]]; then
	AGW_MACEXT=' -@ ' # Mac extended attributes
    else
	AGW_MACEXT=' '
    fi
    
    alias ls="/bin/ls               ${AGW_LS_OPT} "
    alias ll="/bin/ls   -l -h -A -F ${AGW_LS_OPT} "
    alias lmac="ll ${AGW_MACEXT} " # mac-specific with EXTENDED attributes (-@)
fi

alias l='ls'
alias lo='ll -r -t' # Depends on "ll" already being defined above. List by TIME so that NEWEST files are at the bottom
alias p='pwd -P'

alias c='cd'
alias ..='cd ..'
#alias ../='cd ..'
#alias ../../='cd ../../'

#alias ..='pushd ..'
alias res='source ~/.bashrc ; source ~/.bash_profile'
alias mv='mv -i'
alias cp='cp -i'
alias kpk='exit'

alias diffdir='diff -rq' ## diff on directories

# Turn on/off crashplan. No longer necessary.
#alias recrash='sudo launchctl unload /Library/LaunchDaemons/com.crashplan.engine.plist; sleep 1; sudo launchctl load /Library/LaunchDaemons/com.crashplan.engine.plist'

#alias tc='randomize_terminal_color.pl -cycle'
#alias cd='pushd'
#alias b='popd'

# Stop Junos Pulse from automatically starting: from https://gist.github.com/Andrewpk/7558715
# "Be sure to change your /Library/LaunchAgents/net.juniper.pulsetray.plist file to reflect the `KeepAlive` key being set to <false/> as well!"
#alias startvpn2="sudo launchctl load -w /Library/LaunchDaemons/net.juniper.AccessService.plist; open -a '/Applications/Junos Pulse.app/Contents/Plugins/JamUI/PulseTray.app/Contents/MacOS/PulseTray'"
#alias quitvpn2="osascript -e 'tell application \"PulseTray.app\" to quit';sudo launchctl unload -w /Library/LaunchDaemons/net.juniper.AccessService.plist"
startvpn() {
    sudo launchctl load -w /Library/LaunchDaemons/net.juniper.AccessService.plist
    launchctl load -w /Library/LaunchAgents/net.juniper.pulsetray.plist
    open -a '/Applications/Junos Pulse.app/Contents/Plugins/JamUI/PulseTray.app/Contents/MacOS/PulseTray'

}
stopvpn() {
    osascript -e 'tell application "Junos Pulse" to quit';
    osascript -e 'tell application \"PulseTray.app\" to quit';
    launchctl unload -w /Library/LaunchAgents/net.juniper.pulsetray.plist
    sudo launchctl unload -w /Library/LaunchDaemons/net.juniper.AccessService.plist
}

## "showoff" makes it so that everyone can a+rx any directories and a+r any files.
## Note that we don't want to make it so everyone can execute *files* necessarily, just folders
## ("Executing" a folder means you can "ls" it and see what's inside.)
function showoff {
    if [ "$#" -eq 0 ]; then echo "Usage: 'showoff' requires path argument(s)! Example: 'showoff ./' for the current directory."; return; fi
    for var in "$@"; do echo "showoff is now running 'chmod -R' to allow ANY USER to browse \"$var\""; chmod -R a+r "$var" ; find "$var" -type d -type d -exec chmod a+x \{\} \; ; done
}
function sudoshowoff {
    if [ "$#" -eq 0 ]; then echo "Usage: 'sudoshowoff' requires path argument(s)! Example: 'sudoshowoff ./' for the current directory."; return; fi
    for var in "$@"; do echo "sudoshowoff: Using sudo chmod -R to allow ANY USER to browse \"$var\""; sudo chmod -R a+r "$var" ; sudo find "$var" -type d -type d -exec sudo chmod a+x \{\} \; ; done
}

## Mac-specific commands:
SETFILE_LOCATION=/Applications/Xcode*/Contents/Developer/Tools/SetFile
alias invisible='chflags -h hidden'  #alias invisible='chflags hidden' #$SETFILE_LOCATION -P -a V' ## Mac-only: Make a file/folder invisible to the Finder
alias visible='chflags -h nohidden' #alias visible='chflags nohidden' #$SETFILE_LOCATION -P -a v' ## Mac-only: opposite of "invisible"
alias clearicon='$SETFILE_LOCATION -P -a c' ## clear mac custom icons. Useful for images that have old custom icons.
alias version="lsb_release -a" # Tells you which version of Ubuntu you are running!

function mac2unix { # Convert a Mac-style line-ending file to a UNIX one. Useful for when you save a file in Excel and then UNIX won't read it.
    if [[ -f "$1" ]] ; then cat "$1" | tr '\r' '\n' ## if a filename is passed in, then auto-cat that file
    else tr '\r' '\n' ; fi ## otherwise it's probably part of a cmdline pipe
}

function dos2unix { # Convert a Windows-style line-ending file to a UNIX one. Useful for when you save a file in Excel and then UNIX won't read it.
    if [[ -f "$1" ]] ; then cat "$1" | tr -d '\r' ## if a filename is passed in, then auto-cat that file
    else tr -d '\r'; fi ## otherwise it's probably part of a cmdline pipe
}

## Utility commands

## -U: "screen understands UTF8"
alias rr='tmux attach || tmux new' #"screen -xR -U" ## Reconnect to the previous screen, or make a new one if there isn't one already
alias sc='tmux new-window' #'screen' ## Make a new screen session

alias wcl='wc -l'
alias sortt='sort -t "	"' # sort with tab as separator
alias sortg='sort -g -t "	"' # sort NUMBERS, with tab as separator

#if [[ -f /usr/local/bin/emacs ]]; then
#if [[ -n "$isMac" ]]; then
#    alias e='emacs --no-splash -nw ' # use 'brew install emacs' to update emacs
#else
alias e="emacsclient -nw  -c --alternate-editor=\"\"" # "As a special exception, if command is the empty string, then emacsclient starts Emacs in daemon mode (as emacs --daemon) and then tries connecting again."
#fi

#alias t='transpose.pl -q'
alias tattle="echo -e -n '$a_status_color'; ps aux | tail -n +2 | sort --reverse -k 3,3 | head -n 5 | perl -p -e 's/[ ]+/\t/g' | cut -f 1,3,4,11 | cap.pl 'USER,CPU,MEM,TASK' | sheet.pl --color=always \
--ht=75 --trunc=60 | tail -n +2 ; echo -e -n '$a_end_color'"

# GNU Make-related
alias make='make --warn-undefined-variables --print-directory'
alias mcm='make clean && make'
function remake { ## Lets you type "remake" to remove a file and then use GNU make to try to re-generate it
    trash.pl "$@" ;  make --warn-undefined-variables --print-directory "$@"
}

function rel { ## Remake and then view;
    trash.pl "$@" ;  make --warn-undefined-variables --print-directory "$@" ; s "$@"
}

# Aliases related to COLOR GREP
alias grepi='grep   -i' # <-- runs fast if "LANG=C" is the specified language
alias grepc='grep   --color=always --with-filename --line-number'
alias egrepc='egrep --color=always --with-filename --line-number'
alias fgrepc='fgrep --color=always --with-filename --line-number'

# Aliases related to CVS
alias commit="cvs commit -m 'AGW CVS Commit'"
alias gitcom="git commit -a -m 'Changes committed by alexgw'"
alias gitstat="git ls-files --modified --deleted"
alias gitdiff="git difftool"

alias hgcom="hg commit -u '${USER}' -m 'Changes committed by ${USER}' && echo '[Done] committing changes locally with Mercurial.'"
alias hgpush="hg commit -u '${USER}' -m 'Changes committed by ${USER}' && hg push && echo '[Done] pushing changes to the remote server with Mercurial.'"
alias hgpull="hg pull ; hg update && echo '[Done] pulling remote changes and updating the local Mercurial repository.'"
alias hgup="hg update -v && echo '[Done] updating local changes in Mercurial'"
alias hgs="echo '[hg status]:'; hg status; echo '[hg status --rev .:tip]:'; hg status --rev .:tip ; echo 'Note: to see every little detail, type \"hg log --patch -r .:tip\"' "

function hglog {
    hg status
    if [[ $? == "0" ]] ; then  ## <-- only check the log if there is actually a mercurial repo here!
	hg log -p --color=always "$@" | s
    fi
}

function sciencecom {
    if [[ -d "$1/.git" ]] ; then
	echo "Committing GIT changes locally."
	#cd "$1" ; git commit -a -m "Committing changes from ${USER}" ; git push origin master ;
	git --git-dir="$1/.git" --work-tree="$1" commit -a -m "Committing changes from ${USER}"
	echo "Pushing GIT changes to remote master."
	git --git-dir="$1/.git" --work-tree="$1" push origin master ;
    else
	echo "No $1 git repository exists on this machine."
	return 1;
    fi
}

function scienceup {
    if [[ -d "$1/.git" ]] ; then
	echo "Committing any local GIT changes before syncing with remote master."
	git --git-dir="$1/.git" --work-tree="$1" commit -a -m "Committing any local changes from ${USER} before sync with remote server." ;
	echo "Pulling GIT changes from remote master."
	git --git-dir="$1/.git" --work-tree="$1" pull ;
	#cd "$1" ; git --git-dir "$1" commit -a -m "Committing any local changes from ${USER} before sync with remote server." ; git --git-dir "$1" pull ;
    else
	echo "No $1 git repository exists on this machine."
	return 1;
    fi
}


function scihg_com {
    if [[ -d "$1" ]] ; then
	hg commit --user ${USER} --cwd "$1" -m "Commit by ${USER}" ; hg push --cwd "$1" ; echo "[Done] commiting and pushing $1 repository" ;
    else
	echo "No $1 repository exists on this machine."
	return 1;
    fi
}

function scihg_up {
    if [[ -d "$1" ]] ; then
        hg commit --user ${USER} --cwd "$1" -m "Commit of local changes by ${USER} before pull." ;
	hg --cwd "$1" pull ; hg --cwd "$1" update ; echo "[Done] pulling and updating $1 repository"
    else
	echo "No $1 repository exists on this machine."
	return 1;
    fi
}


alias science="echo 'TimeForScience (GitHub):' ; scienceup ${TIME_FOR_SCIENCE_DIR} ; sciencecom ${TIME_FOR_SCIENCE_DIR} ; echo ''; echo 'Work directory:' ; scihg_up ${BINF_CORE_WORK_DIR} ; scihg_com ${BINF_CORE_WORK_DIR}"

AGW_SSH_OPTIONS=" -o ServerAliveInterval=30 -C "

alias nami=' ssh ${AGW_SSH_OPTIONS} -i ~/Dropbox/metaquery-dev.pem bitnami@52.53.252.164'

alias nau=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${BN_IP}'  # From the not-uploaded file /work/Common/Code/alexgw/aliases-server-config (or .aliases-server-config in the home directory!)
alias naux='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${BN_IP}'
alias bus=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${BC_IP}'
alias busx='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${BC_IP}'
alias wes=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${WES_IP}'
alias wesx='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${WES_IP}'

alias rig=' ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${RIG_IP}'
alias rigx='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${RIG_IP}'

alias lig=' ssh ${AGW_SSH_OPTIONS}     ${PL_USERNAME}@${PL_IP}' # <-- LIG = different username!
alias ligx='ssh ${AGW_SSH_OPTIONS} -Y  ${PL_USERNAME}@${PL_IP}' # <-- LIG = different username!

alias bue=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${PB_IP}'
alias buex='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${PB_IP}'
alias che=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${CLUS_IP}'
alias newv='ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${NEWV_IP}'
alias tuck='ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${PS_IP}'

alias oso='ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${OSO_IP}'
alias osox='ssh ${AGW_SSH_OPTIONS} -Y ${ACC_U}@${OSO_IP}'

## ===============================================
## ====== LESS ===================================
export PAGER=less
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)" # make "less" friendly for non-text input files

# Things related to "LESS"
export LESSOPEN="|${TIME_FOR_SCIENCE_DIR}/Config/1_Shell_Config/lesspipe_basic.sh %s"
# lesspipe_basic.sh casues less to transparently decompress gzipped files before showing them
# Old:  '|/usr/bin/lesspipe.sh %s'

alias magicless='env LESSOPEN="|${TIME_FOR_SCIENCE_DIR}/Config/1_Shell_Config/lesspipe_advanced.sh %s" /usr/bin/less -S --RAW-CONTROL-CHARS -f --IGNORE-CASE'
# It's less, but it "magically" handles gzipped files and automatically runs ".tab" files through sheet.pl
# Note that this only magically happens if the files are passed in on the command line--otherwise you have
# to use "ssf" to force sheet.pl to be run (if a file is passed through a pipe, then it won't be run through
# sheet.pl unless you say "cat something | ssf"
## ====== LESS ===================================
## ===============================================

# Plain "sn" doesn't run anything through sheet.pl, but it *does* handle gzipped files
alias sn='/usr/bin/less -S --LINE-NUMBERS --status-column --RAW-CONTROL-CHARS -f --IGNORE-CASE'

alias sweep='trash.pl *.tmp *.temp' ## Sweep out the .tmp files

alias htop='htop --sort-key PERCENT_CPU'

function playnicely {
    # Takes one argument.
    # requires sudo privileges. Takes one argument, the username to make play nicely:
    # example: playnicely THEUSERNAME
    SSS=$(ps -fu "$1" | perl -pe 's/[ ]+/\t/g' | cut -f 2 | tail -n +2);
    for pid in $SSS ; do echo 'ionice-ing and nice+15-ing process ID' $pid; sudo ionice -c3 -p $pid ; sudo renice +15 -p $pid ; done 
}

function disknicely {
    # Takes ZERO arguments. Just for making the 'nfsd' processes less annoying.
    SSS=$(ps -eopid,uid,cmd | grep "nfsd" | grep -v "grep" | perl -p -e "s/^[ ]+//" | cut -d " " -f 1) # Get any 'nfsd' processes
    for pid in $SSS ; do echo 'ionice-ing and nice+15-ing the NFS process ID' $pid; sudo ionice -c3 -p $pid ; sudo renice +15 -p $pid ; done 
}


function acol {
    column -s $'\t' -t # columns delimited by tabs! Like 'sheet.py'
}

function s { ## <-- this needs to come BEFORE the other things that use less!
    # "s" uses "magicless" to run files through sheet.pl
    magicless --LINE-NUMBERS --status-column "$@"
}

function acols {
    s "$@" | acol | s # Pipe it through magicless, then 'acol', then magicless AGAIN. Like a poor man's sheet.py (way faster, though)
}

function sf {
    # Forces sheet.pl to be called ("SS Force sheet.pl").  Can only view ONE file, unlike "ss"
    /usr/bin/less --RAW-CONTROL-CHARS "$1" | sheet.pl --color=always | s
}

function s1 {
    # like sf, but shorter columns # Can only view ONE file, unlike "s"
    /usr/bin/less --RAW-CONTROL-CHARS "$1" | sheet.pl --color=always --trunc=15 | s
}

function s2 {
    # like sf, but shorter columns # Can only view ONE file, unlike "s"
    /usr/bin/less --RAW-CONTROL-CHARS "$1" | sheet.pl --color=always --trunc=25 | s
}

function v {
    # Use sheet.py to view a file or list of files. These files cannot be gzipped, however.
    # Must be python2.6, and not python 3, currently
    python `which sheet.py` "$@"
}

alias huh='cat <(declare -f) <(alias)' ## uses bash subshells to show everything that is defined
alias backoff='~/TimeForScience/Config/Alex_Williams/unix_scripts/crashplan-backup-mod.sudo.sh off'
alias backon='~/TimeForScience/Config/Alex_Williams/unix_scripts/crashplan-backup-mod.sudo.sh on'

function n { # show colors
    echo -e  "$color_prefix[30m black $color_prefix[31mred $color_prefix[32mgreen $color_prefix[33myellow $color_prefix[34mblue $color_prefix[35mmagenta $color_prefix[36mcyan $color_prefix[37mwhite"
}

## Maczip zips things on the mac WITHOUT including the dot files and .DS_Stores
function maczip {
    if [[ "$#" == 1 ]] ; then theCompressedBasename="$1"; ## If you pass it one argument, then that argument will also be the filename
    else theCompressedBasename="Archive_zipped_without_Mac_files";
    fi
    theCompressedBasename=`echo "$theCompressedBasename" | sed "s/[/]//"` ## Let's remove any slashes from the name of the *output*. That way if someone types "mini MyDir/" it will generate "MyDir.zip" and NOT "MyDir/.zip"
    if [[ -f "${theCompressedBasename}.zip" ]] ; then
	echo "mini: HALTING: Cannot create a new archive---perhaps ${theCompressedBasename}.zip already exists.\nThis is forbidden--you cannot create the archive to overwrite the current archive!!! Delete it and compress again." ;
	return ;
    else
	if [[ "$#" -gt 1 ]] ; then echo "Adding a total of $# files to the new zip archive, which OMITS Mac-specific files (e.g. .DS_Store)." ; fi
	for var in "$@"; do echo " * Archiving $var --> ${theCompressedBasename}.zip" ; done
	echo "[ZIP] command running now..." ;
	zip -9 -r -X --symlinks --exclude "*.DS_Store" --exclude="*~*" --exclude="*\$*" "${theCompressedBasename}.zip"  $@;
	echo "[Done]" ;
    fi
}

## Mini is a function that creates a .bz2 archive of whatever you pass into it.
## It works in a manner similar to right-clicking and zipping a file on the Mac.
## If you just pass it in ONE file named FILE, then the output filename is "FILE.tar.bz2" .
## If you give it multiple files, the output is in Archive.tar.gz
## To extract a "mini" archive, use "unmini" .
# Bugs: it ONLY WORKS IN THE CURRENT DIRECTORY! And it probably hates whitespaces.
# maybe this will help with escaping? for f in `ls`; do printf "%q " $f; done
# looks like 'printf' can save the day
function mini {
    [[ "$#" == 1 ]]         && compressedBasename="$1" || compressedBasename="Archive" ## If you pass it one argument, then that argument will also be the filename
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD / Mac, so check for it
    
    compressedBasename=`echo "$compressedBasename" | sed "s/[/]//"` ## Let's remove any slashes from the name of the *output*. That way if someone types "mini MyDir/" it will generate "MyDir.tar.bz2" and NOT "MyDir/.tar.bz2"
    if [[ $(tar --version) =~ .*bsdtar.* ]]; then TAREX=" -c -v "      # BSD tar
    else TAREX=" --preserve-permissions --atime-preserve -c -v "; fi   # GNU tar
    if [[ -f "${compressedBasename}.tar" || -f "${compressedBasename}.tar.bz2" ]] ; then
	echo "mini: HALTING: Cannot create a new archive---either ${compressedBasename}.tar or ${compressedBasename}.tar.bz2 already exists.\nThis is forbidden--you cannot create the archive to overwrite the current archive!!! Delete it and compress again." ;
	return ;
    else
	if [[ "$#" -gt 1 ]] ; then echo "Adding a total of $# files to the archive." ; fi
	for var in "$@"; do echo " * Archiving $var --> ${compressedBasename}.tar.bz2" ; done
	echo "[TAR] command running now..." ;
	echo "$AGW_IONICE tar ... $TAREX"
	eval "$AGW_IONICE" tar "$TAREX" --bzip2 -f "${compressedBasename}.tar.bz2" $@;
	echo "[Done]" ;
    fi
}

## Extracts any number of compressed files. Usage: 'unmini a.bz2 b.tar.gz c.tar.bz2 ... etc...'
function unmini {
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD / Mac, so check for it
    if [[ $(tar --version) =~ .*bsdtar.* ]]; then TARPARAM=" -x -v "                 # BSD tar
    else TARPARAM=" --preserve-permissions --atime-preserve --keep-old-files -x -v "; fi # GNU tar
    for an in "$@"; do # Loop through all the input arguments
	echo " * Decompressing \"$an\"..."
	case "$an" in 
	    *.tar.gz)  EX_CMD="tar $TARPARAM --ungzip -f " ;; 
	    *.tar.bz2) EX_CMD="tar $TARPARAM  --bzip2 -f " ;; 
	    *.tar)     EX_CMD="tar $TARPARAM          -f " ;; 
	    *.gz)      EX_CMD="gzip  --decompress " ;; 
	    *.bz2)     EX_CMD="bzip2 --decompress " ;;
	    *.zip)     echo "ZIP commands are a disaster and are not supported yet. Sorry."; return ;;
	    *) echo "unmini has failed to detect type of archive (filename is <$an>. Recommendation: make sure that file exists)... aborting." ; return ;;
	esac
	eval "$AGW_IONICE" "$EX_CMD" "$an" # <-- actually decompress the file
    done
}

# function singlea {
#     # Requires exactly ONE argument!
#     if [ -f "$1/.describe" ]; then
# 	echo -e "\n-------------------------------------------------"
# 	cat .describe
# 	echo "-------------------------------------------------"
#     fi
#     ls $1
# }

# function aa {
#     PREFIX="./"
#     if [ $# -eq 0 ]
#     then
# 	singlea "./"
#     else
# 	for arg in "$@"
# 	do
# 	    singlea "$arg"
# 	done
#     fi
# }

#function qin { # qstat with colors for job status, automatic piping into "less" --- this is now the "qselect.sh" script

alias snake="echo  $'\xF0\x9F\x90\x8D'"  # See http://apps.timwhitlock.info/emoji/tables/unicode
alias cake="echo   $'\xF0\x9F\x8D\xB0'"  # See http://apps.timwhitlock.info/emoji/tables/unicode

function qkiri { # kill all your OWN jobs
    echo ">> If qkiri fails, try running this command: qselect -u YOURNAME | sudo xargs qdel -p"
    echo "   Note: that command requires 'sudo'"
    qselect -u $USER | xargs qdel ; echo "[Cancelled jobs]"; sleep 1; qstats;
}

# grep 'pattern' can also be replaced with: perl -nle "print if m{PATTERN}" # <-- beware of '$1' versus "$1" issues!

function qstatlong { # show qstat with LONG (full) job names:
    qstat -f | egrep -i '(Job Id|Job_Name|Job_Owner|job_state|list.walltime)' | perl -pe 's/(.*Job_Owner.*)@.*/\1/i' | perl -pe 's/.*=\s//' | perl -pe 's/\n/\t/g' | perl -pe 's/(Job Id:\s|$)/\n/ig' | grep -v '^$'
}

function qsass { # kill all jobs that match this grep... works for usernames, jobs, etc. Be careful!
    # Example usage:  qsass    yourname             # Hopefully yourname is not a subset of someone ELSE's name!
    # or:             qsass    test_job_number_     # Uses GREP, so watch out for invalid regexps!
    sudo echo 'Initializing sudo permissions here'
    if [[ ${#1} -lt 4 ]]; then
	echo "ERR: Your argument to qsass ($1) was not long enough (it is only length ${#1})---it needs to be at least 4 characters, or else we don't believe it's a valid input! Be careful! Even PARTIAL MATCHES will trigger the job deletion. So don't delete 'bad_job' if you don't also want to delete 'not_a_bad_job'."
	return 1;
    fi;
    echo "Trying to use qdel to delete jobs that match '$1'...";
    IFS=$'\n' # <-- split a bash string on NEWLINES and not spaces!
    DELETE_US=()
    for jobtext in $(qstatlong | perl -nle "print if m{$1}"); do
	jobid=$(echo "$jobtext" | cut -d '.' -f 1)
	echo "Found a job ID to delete that matched '$1': $jobid (\"$jobtext\")";
	DELETE_US+=("$jobid")
    done
    echo "If you really want to DELETE those jobs, input a '2'."
    select yn in "Wrong! Keep these jobs!" "Delete these jobs from the queue!"; do
	case $yn in
	    Delete*) for j in "${DELETE_US[@]}"; do echo "Deleting job ID $j..."; sudo `which qdel` $j ; done; break;;
	    Wrong*)  echo "Cancelled!"; break;;
	esac
    done
}

function checkbackup {
    # checks the MOST RECENT file in /it/backup/log, and gives you the last 10 lines from that file
    echo ""
    echo "Reporting the last 10 lines of the most recent backup on this machine."
    echo "If these lines are not from yesterday or today's date, then something is seriously wrong!"
    tail -n 10 /it/backup/log/$(ls -1t /it/backup/log/ | head -n 1)
    TODAY=$(date +"%Y%m%d")
    YESTERDAY=$(date +"%Y%m%d" --date='1 day ago')
    LAST_BACKUP_DATE=$(ls -1t /it/backup/log/ | head -n 1 | cut -f 1 -d '-')
    [[ ("$LAST_BACKUP_DATE" == "$TODAY") || ("$LAST_BACKUP_DATE" == "$YESTERDAY") ]]; RESULT=$?
    if [[ $RESULT -ne 0 ]] ; then echo -e "***\n**\n*\n******************** WARNING --- last backup date was on $LAST_BACKUP_DATE ************\n*\n**\n***";
    else echo -e "\nOK: The last backup ($LAST_BACKUP_DATE) was made within the last 2 days.\n"; fi
}


function workarchive { # usage: cd /work/projects  then: "workarchive myproj-1234-rna-mouse"  --> will move things to bag_of_holding/work_archive/
    D=${1%/}
    DARCH=${D}_ARCHIVE
    TARGET=/bag_of_holding/work_archive/${D}
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD / Mac, so check for it
    echo "We would like to move the directory (without a slash) \"${D}\" to the final TAPE DRIVE target \"${TARGET}\"... sound ok to you? Select a NUMERIC option below:"
    select yn in "[Cancel]" "Move those files!"; do
	case $yn in
	    Move*) sudo mv ./${D} ./${DARCH}
		 ln -s ${TARGET} ./${D}
		 eval sudo ${AGW_IONICE} mv ./${DARCH}  ${TARGET}
		 break;;
	    *) echo "Ok, not doing anything."; break;;
	esac
    done
}

function mvln { # move and then make an ALIAS where the previous file was
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE filename (source) and ONE DESTINATION (probably a directory?) into this function!"; return; fi
    if [[ "$#" != 2 ]] ; then echo "[ERROR] Right now, this only works with TWO ARGUMENTS (target and destination)!"; return; fi
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD / Mac, so check for it
    FILE=$1
    if [[ ! -e $FILE ]] ; then echo "[ERROR] Your source file ($FILE) does not exist!"; return; fi
    LAST=${@: -1}
    if [[ -d $LAST ]]; then # target is a directory
	eval $AGW_IONICE mv "$FILE" "$LAST/"
	ln -s "$LAST/$FILE" "$FILE"
    else # target is a file
	eval $AGW_IONICE mv "$FILE" "$LAST"
	ln -s "$LAST" "$FILE"
    fi
    #touch $LAST
    #if [[ ! -e $FILE ]] ; then echo "[ERROR] Your source file ($FILE) does not exist!"; return; fi
}

function neararchive { # usage: cd /work/projects/your-project  then: "neararchive myproj-1234-rna-mouse"  --> will move things to the nearline storage and symlink them back
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE filename into this function!"; return; fi
    D=$(basename `pwd`)
    TARGET="/nearline_storage/castles_made_of_sand/not_backed_up/${D}"
    echo "We would like to move the following $# files to the NEARLINE SECONDARY STORAGE folder <${TARGET}/>... sound ok to you? Select a NUMERIC option below:"
    ls -1 -lh $@
    select yn in "[Cancel]" "Move those files!"; do
	case $yn in
	    Move*) mkdir -p "$TARGET"; for f in "$@"; do mv "$f" "${TARGET}/" && ln -s "${TARGET}/$f" ./ ; echo "Moved <$f> to <${TARGET}/$f>..." ; done; break;;
	    *) echo "Ok, not doing anything."; break;;
	esac
    done
}

function accuse { # See who is using the CPU. Usage: just "accuse" with no arguments
    USERS_WITH_JOBS=$(ps aux | tail -n +2 | cut -d ' ' -f 1 | uniq | sort -u)
    echo -e ">> Let's see who is using the CPU..."              >&2 # print to stderr
    echo -e ">> Going to check these users: ${USERS_WITH_JOBS}" >&2 # print to stderr
    TOPTEMP=$(mktemp) # Make a temp file
    TEMP2=$(mktemp)   # Make another temp file
    D=$(date '+%F %H:%M:%S')
    top -b -n 1 | tail -n +7 >> ${TOPTEMP} ;
    echo -e "USERNAME\t%CPU\tBARGRAPH\t# Date = \"${D}\"" >> ${TEMP2}
    NCPU=$(nproc)
    for u in $USERS_WITH_JOBS; do \
	cat $TOPTEMP | perl -e "my \$user = ${u}; my \$tot = 0; while(<>){ chomp; my @a=split(/\s+/); if (\$a[2] =~ m/${u}/i) {\$tot += \$a[9];}; } my \$stars = '|' . 'x' x (1+int((\$tot+50)/${NCPU})); print qq{\$user\t\$tot\t\$stars\n};"  >> ${TEMP2}; \
    done ;
    cat ${TEMP2} | column -t -s $'\t'
    /bin/rm ${TOPTEMP} ${TEMP2}
}

function giant { # find giant files
    #SAVED_IFS=$IFS; IFS=$(echo -en "\n\b")
    echo "Calculating all sizes first, then sorting them in ascending order..." >&2 # print to stderr
    DIRS="$@"
    sudo du -sc $DIRS | perl -nle 'print if not m/\btotal\b/' | perl -nle "@a = split(/\s+/); if (\$a[0]>0){print ((\$a[0]/1024.0/1024.0).qq{\t}.\$a[1]);} else { };" | sort -k1,1g | perl -e "my \$t = 0; while(<>) { my @a=split; \$t += \$a[0]; print join(qq{\t}, int(\$t/1024.0).qq{T}, int(\$a[0]).qq{G}, \$a[1]).qq{\n} }"
    #IFS=$SAVED_IFS
}

function wholog {
    echo "About to show who logs in and how big their home directories are..." >&2 # print to stderr
    TMP=$(mktemp)
    for f in $(cat /etc/passwd | cut -d ':' -f 1); do echo "Checking $f..." >&2 ; sudo lastlog -u $f; done | grep -v '^Username' | perl -pe 's/\s+/\t/' > $TMP
    sudo du -sch /home/* | perl -pe 's/\/home\///' | join.pl -o "NO_HOMEDIR" -1 1 -2 2 $TMP - | column -t -s $'\t'
}

function qing {
    echo "'qing' is 'qstats' but only showing NON-COMPLETED jobs..."
    echo "Note that 'qstat -f' may fail in cases where 'qstat' does not. Try plain 'qstat' if this command seems to be taking forever."
    echo "'qstat -f' has been known to take upwards of 2 minutes to run."
    qstats | grep -v ' COMPLETE '
    qstat -f -Q
}

function mypylint {
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE PYTHON filename into this function!"; return; fi
    echo "Lintifying this file... $FILE"
    DISABLE_THESE_CHECKS="locally-disabled,global-variable-not-assigned,line-too-long,superfluous-parens,bad-whitespace,unused-wildcard-import,trailing-whitespace,unnecessary-pass,missing-docstring,invalid-name,global-statement,multiple-statements,too-many-locals,too-many-statements,too-many-branches,too-few-public-methods,too-many-lines,too-many-instance-attributes,too-many-arguments,wildcard-import,bad-continuation,unidiomatic-typecheck,expression-not-assigned,deprecated-lambda"
    pylint --jobs=4 --output-format=colorized --disable=$DISABLE_THESE_CHECKS "$@"
    # Best usage is: mypylint | s for viewing the colorized output!
}

function mo {
    # Based on file extension, turns something into plain text! Works on mixed files. Only delves one level of compression deep.
    for name in "$@"; do # Loop through all the input arguments. Doesn't work with redirection.
	VC="cat" # This is the default
	filetype=$(file --brief "$name")
	case "$name" in
	    *.bam)  VC="samtools view -h " ; filetype="BAM_FILE_DETECTED_AGW";;
	esac
	case "$filetype" in 
	    gzip*)  VC="gzip  --decompress --stdout " ;; 
	    bzip2*) VC="bzip2 --decompress --stdout " ;;
	esac
	$VC "$name" # <-- actually decompress the file and print it to stdout
    done
}

alias tab="column -t -s $'\t'"

function brutallycompress {
    # Usage:    brutallycompress  DIRECTORY1   DIRECTORY2   DIRECTORY3
    # Recursively goes through and compresses (gzip -9) any files with the extensions listed below.
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE target directory into this function!"; return; fi
    COMPRESS="gzip --verbose -9"
    echo "About to compress ($COMPRESS) anything that has the extension: .bed, _tracking, .diff, .bed.count, .moa, .fa, .fq, .fasta, .fastq, .txt"
    for location in "$@"; do # Loop through all the input arguments. Doesn't work with redirection.
	if [[ ! -d "$location" ]] ; then echo "[ERROR]: input '$location' was not a directory!"; return 1; fi
	find "$location" -type f \( -iname "*.bed" -o -iname "*_tracking" -o -iname "*.diff" -o -iname "*.bed.count" -o -iname "*.moa" -o -iname "*.fa" -o -iname "*.fq" -o -iname "*.fasta" -o -iname "*.fastq" -o -iname "*.txt" \) -print0 | xargs -0 $COMPRESS
    done
}

function rtag {
    # Recursively set finder tags
    tag=$1
    shift
    for fff in "$@"; do # Loop through all the input arguments. Doesn't work with redirection.
	#find . -exec tag --add tagname {} \;  -print
	#find $name -type f | xargs xattr -wx com.apple.FinderInfo "`xattr -px sampleFile`"
	echo "Adding tag $tag to $fff"
    done
}

function wgetdevour { # wget devour
    if [[ "$#" != "3" ]] ; then echo "[ERROR] You need to pass THREE arguments -- username, password, directory!"; return; fi
    USERNAME=$1
    PASSWORD=$2
    DIRECTORY=$3
    wget -mk -r -U mozilla --connect-timeout=90 --random-wait -e robots=off --limit-rate=1m --tries=99 --timeout=50 \
	 -A md5,fasta,fa,fastq,fq,bz2,gz,Z,gzip,bzip2,pdf,xls,xlsx,bed,sam,bam,vcf,csv,txt,sh,complete \
	 --no-parent \
	 --http-user="$USERNAME" --http-passwd="$PASSWORD" "$DIRECTORY/" # trailing slash here is crucial
}




