# -*-Sh-*- <-- tells emacs what kind of syntax highlighting to use

# ---------------------
# "Unofficial bash strict mode: " #!/bin/bash
# set -euo pipefail
# IFS=$'\n\t'
# ---------------------
if [ -f ${BINF_CORE_WORK_DIR}/Code/alexgw/aliases-server-config ]; then
    source ${BINF_CORE_WORK_DIR}/Code/alexgw/aliases-server-config
elif [ -f ~/.aliases-server-config ]; then
    source ~/.aliases-server-config
fi

if [ -f ~/.local-config-no-git ]; then
    source ~/.local-config-no-git
else
    echo "Note: no .local-config-no-git was found. SSH commands, server shortcuts, and tmux coloring may fail. You may want to MANUALLY copy this file over from another machine."
fi

if [[ "$USER" == "alexgw" ]] || [[ "$USER" == "awilliams" ]] || [[ "$USER" == "alexwilliams" ]]; then
    ## SAFER 'rm' COMMANDS --only applies to the user(s) above.
    ## Below: aliases the command "rm" to actually run the script "trash.pl," which moves files to a trash directory in /tmp.
    ## They can be recovered by just copying them back.
    ## Use the "checktrash" command to find the trash directory if you forget where it is.
    ## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
    alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'
    alias emptytrash='mkdir -p /tmp/${USER}/Trash/ && /bin/rm -rfv /tmp/${USER}/Trash/ && echo "Emptied the trash directory (/tmp/${USER}/Trash)" ;'
    alias rm='trash.pl' ## <-- Note that the "real" rm can still always be invoked by '/bin/rm'
fi

# git config --global user.name "alexgraehl" ; git config --global user.email "alexgraehl@users.noreply.github.com"
echo -e "${a_echo_color}>>> BASH: Loading bash-aliases...${a_end_color}"
#echo $GIT_COMMITTER_EMAIL
# echo $GIT_AUTHOR_EMAIL # not important if you set the other thing

CODE_DIRS_FOR_GREPPING="${R_BINF_CORE} ${BINF_CORE_WORK_DIR}/Code/ProjectCode ${BINF_CORE_WORK_DIR}/Code/system_scripts ${BINF_CORE_WORK_DIR}/Code/alexgw ${TIME_FOR_SCIENCE_DIR}"

## Searches both the R source and the current directory (and any subdirectories!)
## Note that it only looks for files with a ".R" ending!!!!!!!
if [[ -n "$isMac" ]] ; then
    ## It *is* a mac!
    function ff {
	`which grep` --color=always --ignore-case --recursive --extended-regexp --exclude="Mothballed" --exclude=".hg" --exclude="CVS" --exclude="[bB]ackup*" --exclude="Annotation*.txt" \
	    "$@" ${CODE_DIRS_FOR_GREPPING} ./
    }
    alias zcat='gunzip -c' ## On the Mac, "zcat" likes to append '.Z' to filenames. Super annoying.
else
    ## Not the mac!
    function ff {     ## Annoyingly, grep is different between mac/unix
	cmd=(	grep --color=always -T \
	    --ignore-case \
	    --recursive \
	    --extended-regexp \
	    --line-number --with-filename \
	    --exclude-dir="Mothballed" --exclude-dir="\.hg" --exclude-dir="CVS" --exclude-dir="[bB]ackup*" \
	    --binary-files=without-match \
	    --include=*.R --include=*.pl --include=*.pm --include=*.py --include=*.sh --include=*.py )
	cmd=( "${cmd[@]}" "$@" ${CODE_DIRS_FOR_GREPPING} ) # some weird array format
	"${cmd[@]}" # <- Actually execute. See http://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
    }
fi

function hunt { # cd into a directory with a script
    echo "Hunting the most dangerous game of all: cd-ing the directory where \"$(basename $(which $1))\" lives..."
    THEDIR=$(dirname $(which $1 | head -n 1))
    cd "$THEDIR"
    echo "Moved into directory <$THEDIR>."
}

function cto { # instead of CD to a file, CD directly to a file's directory, since naturally you can't actually CD to a file
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass EXACTLY ONE filename or directory name into this function!"; return; fi
    if [[ -d "$1" ]] ; then cd "$1" ; return 0; fi # it's already a directory, change to it!
    TO=$(dirname "$1")
    cd "$TO"
}

function witch { # Shows the versions for all on-your-path verisons of software.
    # Takes ONE required argument: the program name. Can also take a SECOND argument, which is the actual command to run to check versions (if it isn't 'version')
    # Example:   witch emacs
    #               This works, because 'emacs --version' is how you get the version
    # But for Java, you have to say the following:
    # Or:        witch java -version   (some programs are dumb and do not support --version)
    #               Since the default "--version" doesn't work with Java
    VER_STR=" --version "
    if [[ "$#" == 0 ]]; then
	echo "ERR: You need to specify a program to check the versions of. Example:  witch emacs --version ."
	return 1;
    fi
    if [[ "$#" == 1 ]] ; then echo "witch: Using default '--version' to check for program version..."; fi
    if [[ "$2" != "" ]]; then
	# $2 was actually defined...
	VER_STR="$2"
	#echo "ERR: You need to specify a version-obtaining-argument like '--version' to the 'witch' command";
	#echo "     Example:   witch emacs --version   or java -version (Java doesn't support --version)";
	#return 1;
    fi
    for f in $(which -a "$1"); do echo -en "\n${a_echo_color}$f${a_end_color} --> "; eval "$f $VER_STR" | head -n 2; done; echo ""
}

function phageomancy-all {
    PREFIXES=$(ls -1 p*.gz | grep -E '(fastq|fq).gz$' | perl -pe 's/_R.*//' | sort -u)
    for f in $PREFIXES; do
	echo "Handling $f ..."
	PHAGEOMANCY_PY=`which phageomancy_pipeline.py`
	RESOURCE_DIR=$HOME/PHAGEOMANCY/resources
	ipython --pdb ${PHAGEOMANCY_PY} -- --mode="ALL" --name="${f}" --fqguess --resources="${RESOURCE_DIR}"
    done
}

function phageomancy-one {
    echo "Handling ${1} ..."
    PHAGEOMANCY_PY=`which phageomancy_pipeline.py`
    RESOURCE_DIR=$HOME/PHAGEOMANCY/resources
    ipython --pdb ${PHAGEOMANCY_PY} -- --mode="ALL" --name="${1}" --fqguess --resources="${RESOURCE_DIR}"
}

function delve {
    ## Finds, in any subdirectories, any files that have a name that matches the input text. Sort of like a poor man's "locate"
    find ./ -iname "*$@*"
}

BRACKET_OPEN='{'
PAREN_OPEN='('
TAB='	'
NL="\$'\\n'" # newline!
alias t="transpose.pl"
alias cheat="echo \
\">> Phageomancy on one dir: f=p000z_k00c3_s0037~p000z_S4_L001 && phageomancy_pipeline.py --mode=ALL --name=\\\$f --fqguess --phacts-dir=\\\$HOME/PHAGEOMANCY/PH_PHACTS_EXE/PHACTS/ --spades-n=5 \" ${NL}\
\">> Rscript/R read STDIN: One-liner R and perl extravaganza for plotting contig lengths:  cat contigs.fasta  | perl -ne 'next if not m/^>/; chomp; m/>NODE_(\d+).*length_([\d.]+).*cov_([\d.]+)/; print join(qq{\t}, \\\$1, \\\$2, \\\$3).qq{\n};' | Rscript --vanilla -e 'ddd=read.table(file(\\\"stdin\\\"),header=F,row.names=1); pdf(\\\"a.pdf\\\"); plot(ddd[,1], ddd[,2]); dev.off();' \" ${NL}\
\">> Docker list even EXITED containers: docker ps -a \" ${NL}\
\">> Docker connect interactively no matter what: docker run --name prokka -v '/:/MacRoot/' -i -t --entrypoint '/bin/bash' YOURIMAGE \" ${NL}\
\">> Docker start a container from an image 1: docker run --name NEWNAME --rm -i -t IMGNAME bash \" ${NL}\
\">> Docker start a container from an image 2: docker run -it 0134abd1356  <-- check 'docker images' for a list of images \" ${NL}\
\">> Docker attach to container: docker exec -it CONTAINERNAME bash \" ${NL}\
\">> Echo emoji to terminal: example: a snake is echo $'\xF0\x9F\x90\x8D' (See http://apps.timwhitlock.info/emoji/tables/unicode) \" ${NL}\
\">> Safari: Disable page previews: defaults write com.apple.Safari DebugSnapshotsUpdatePolicy -int 2 \" ${NL}\
\">> Unzip files into SUBDIRECTORIES always: ls *.zip|awk -F'.zip' '{print \\\"unzip \\\"\\\$0\\\" -d \\\"\\\$1}'|sh  \" ${NL}\
\">> ZIP on Mac without the dot files: zip -r -X out.zip input_directory_here    -x \\\"*.DS_Store\\\" \" ${NL}\
\">> RAM/Filesystem: clear out disk cache, recover RAM: purge \" ${NL}\
\">> Mac: what program is using a disk / preventing eject: sudo lsof -xf +d /Volumes/THEVOL \" ${NL}\
\">> Mac disk: specific file I/O: fs_usage <programname> \" ${NL}\
\">> Mac disk: filesystem I/O:    fs_usage -w | grep -v '0\\.0'  \" ${NL}\
\">> Mac set startup disk: sudo bless -mount /Volumes/YOURDISK -setBoot \" ${NL}\
\">> Mac: show weird file flags: ls -l -@ \" ${NL}\
\">> Mac Time Machine: exclude/check: tmutil isexcluded/tmutil addexclusion (-p) PATH \" ${NL}\
\">> Mac Time Machine: delete backups: tmutil delete /Volumes/DISK/Backups.backupdb/COMPNAME/ \" ${NL}\
\">> Mac: recursively clear worthless quarantine flags: xattr -r -d com.apple.quarantine FILENAME \" ${NL}\
\">> Mac: delete impossible-to-delete files find FILE -flags schg -exec chflags noschg {} \\; \" ${NL}\
\">> Mac: show library: chflags nohidden ~/Library/ \" ${NL}\
\">> Mac: batch change modification time: find . -print0 | xargs -0 SetFile -d '12/31/2012 12:00:00 PM' \" ${NL}\
\">> Mac: No quarantine warn  : defaults write com.apple.LaunchServices LSQuarantine -bool NO \" ${NL}\
\">> Mac: check code signing: codesign -vvv /Applications/iTunes.app \" ${NL}\
\">> Mac: No .DS_Store servers: defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool YES \" ${NL}\
\">> Mac: Select in QuickLook (buggy!): defaults write com.apple.finder QLEnableTextSelection -bool YES \" ${NL}\
\">> Mac: No smooth scroll: defaults write -g NSScrollAnimationEnabled -bool NO \" ${NL}\
\">> Mac/cron : edit crontab cron.tab with emacs: env EDITOR=emacs crontab -e \" ${NL}\
\">> Delayed sudo: sudo sh -c \\\"(sleep 3600; do your command here )\\\" \" ${NL}\
\">> Image SIPS: PNG -> JPEG: mkdir outjpegs; sips -s format jpeg *.png --out outjpegs \" ${NL}\
\">> Imagemagick SVG -> PNG: convert -format png -background transparent -density 300 in.svg out.png (see also the -resize 100 option)\" ${NL}\
\">> Imagemagick convert multi-page pdf: for a in \\\$(seq 90); do echo \\\"Converting page \\\$a...\\\"; convert -quality 80 your.pdf[\\\$a] OUT_page_\\\$a.jpg ; done   (note: REQUIRES ghostscript (brew install gs) or it will crash) \" ${NL}\
\">> Imagemagick convert recursive: find ./ -name \\\"*.jp*\\\" -print0 | xargs -0 -I{} convert -resize 1024x768 -quality 85 {} {}  # or resize 50%\" ${NL}\
\">> Imagemagick convert all PDFs in a dir: for f in *.pdf ; do echo \\\"Converting \\\$f...\\\"; convert -verbose -density 144 \\\$f +antialias \\\${f/.pdf}.png; done \" ${NL}\
\">> Imagemagick convert PDF -> PNG w/antialias and downsample: convert -verbose -density 144 in.pdf +antialias out.png   (note: REQUIRES ghostscript (brew install gs) or it will crash)  Note that argument order is very important and may not be correct here. It is also very slow..\" ${NL}\
\">> MP3: Convert m4a/ogg->mp3 for name in *.ogg; do ffmpeg -i \\\"\\\$name\\\" -ab 256k -map_metadata 0:s:0 \\\"Converted_\\\${name/.ogg/.mp3}\\\"; done; \" ${NL}\
\" \" ${NL}\
\">> Check directories for differences (by modification time): ionice -c3 rsync --dry-run --delete -vr /dirA /dirB \" ${NL}\
\">> Find all .R files in a directory:   find ./ -name \\\"*.R\\\" -exec ls \'{}\' \\\; \" ${NL}\
\">> DIFF directories:   diff -rq DIR1 DIR2 \" ${NL}\
\" \" ${NL}\
\">> BASH script header (5 lines): #!/bin/bash -u __NEWLINE__ set -e __NEWLINE__ set -o pipefail __NEWLINE__ set -o xtrace __NEWLINE__ shopt -s nullglob __NEWLINE__ shopt -s globstar \" ${NL}\
\">> BASH: Literal tab: \$'\\t' (example: join -t \$'\\t' to join on tabs) or \\\$(echo -en '\\t') . In MAKE: printf '\\t' \" ${NL}\
\">> SH  : Get directory of this script (fails if last item is a symlink): DIR_OF_SCRIPT=\\\"\\\$( cd \\\"\\\$(dirname \\\"\\\${BASH_SOURCE[0]}\\\" )\\\" && pwd )\\\" \" ${NL}\
\" \" ${NL}\
\">> PYTHON: iPython auto-reload a module before each run: %load_ext autoreload (newline)  %autoreload 2  from foo import some_function (<-- the import is only needed ONE time now!) \" ${NL}\
\">> PYTHON debug a crashing program (worse):  python -m pdb YOURPROG -some -args -here . 'c' continues execution, 's' steps. \" ${NL}\
\">> PYTHON debug a crashing program (better): ipython --pdb YOURPROG --  -more -args -here  'c' continues execution, 's' steps. \" ${NL}\
\">> PYTHON debug a crashing program by enterint the debugger at a specific point:  import pdb; pdb.set_trace() \" ${NL}\
\">> PYTHON / PIP install locally to home directory -> .local: pip2.7 install --user PACKAGENAME \" ${NL}\
\">> PYTHON / PIP install locally to home directory -> .local: pip2.7 install --ignore-installed --install-option=\\\"--prefix=$BINFPYROOT\\\" PACKAGENAME \" ${NL}\
\">> PYTHON debug a crashing program: Put this in the code verbatim to properly enter the debugger at a specific point:  import pdb; pdb.set_trace() \" ${NL}\
\" \" ${NL}\
\">> BIOM format: convert FROM BIOM   : biom convert -i INPUT.biom -o TABDELIM.txt  --to-tsv  --header-key=taxonomy \" ${NL}\
\">> BIOM format: convert BACK TO BIOM: biom convert -i TABIN.txt  -o OTUTABLE.biom --to-hdf5 --table-type=\\\"OTU table\\\" --process-obs-metadata taxonomy \" ${NL}\
\">> R: Save copy of figure as pdf: dev.copy2pdf() \" ${NL}\
\">> R: Convert columns of a dataframe to factors (from char): fact.df   <- char.df; fact.df[] <- lapply(char.df[], as.factor) \" ${NL}\
\">> R: Prevent blank page in PDF: pdf(..., onefile=FALSE) \" ${NL}\
\">> R: Aggregate rows / average rows with same name (mean): mAGG <- t(sapply(by(MAT,rownames(MAT),colMeans),identity)) \" ${NL}\
\">> R: Read bzip/gz file:  x <- read.table(bzfile(\\\"name.bz2\\\") or gzfile(...) \" ${NL}\
\">> R: Read from stdin:    x <- read.table(pipe(\\\"cat something name.bz2 | bunzip2\\\") \" ${NL}\
\">> R: Pick CRAN mirror, no GUI popup (install.packages): chooseCRANmirror(graphics=F) \" ${NL}\
\">> R: Install package from source:  R CMD INSTALL packagename.tar.gz  (or use biocLite(...) or install.packages(...)) \" ${NL}\
\">> R: sessionInfo(): show packages. ls('package:something') shows details. '.libPaths()' shows lib dirs. \" ${NL}\
\">> R: traceback() - to properly debug. Also: options(error=recover()) \" ${NL}\
\">> R: t.test failing? Use tryCatch: tryCatch(something, error=function() { return('NA'); }); \" ${NL}\
\">> R: Need to un-list things? Use unlist! \" ${NL}\
\">> R: Perpendicular axis labels: las=2 (1=horiz, 3=vertical) \" ${NL}\
\">> R: draw beyond graph region: par(xpd=T/F/NA) \" ${NL}\
\">> R: square plot: par(pty='s') \" ${NL}\
\">> R: figure out attributes of a variable: attr(x, 'theAttribute'); Works even when names()/attributes() does not! \" ${NL}\
\">> R: inspect object: str(...) \" ${NL}\
\">> R: totally blank plot: plot(c(0,1),c(0,1),ann=F,bty='n',type='n',xaxt='n',yaxt='n') \" ${NL}\
\">> R: cut things into bins, like a histogram: cut(...) \" ${NL}\
\">> R: factor -> Integers: unclass(...) \" ${NL}\
\">> R: Perpendicular axis: par(las=2) (1 = horiz, 3 = vertical) \" ${NL}\
\">> R: Draw BEYOND the axes / plot region: par(xpd=...) \" ${NL}\
\">> R: Show package contents: ls('package:some_package_name_here') \" ${NL}\
\">> R: Show versions of installed packages: sessionInfo(...) \" ${NL}\
\">> R: Collapse a list down to a basic vector: unlist(...) \" ${NL}\
\">> R: Resize terminal width / columns: options(width=Sys.getenv(\\\"COLUMNS\\\")) \" ${NL}\
\">> R: write.table(DATA, file='x.txt', row.names=T, col.names=NA, sep='\t', quote=F)  \" ${NL}\
\">> R: make libraries usable by non-root users: sudo chmod -R a+r /usr/local/lib/R ; sudo find /usr/local/lib/R -type d | sudo xargs chmod a+x \" ${NL}\
\">> R: run in the queue: qplz \\\"R CMD BATCH script.R\\\" or RScript, but be sure to 'library(methods)' if you use horrendous Rscript \" ${NL}\
\">> R: update all installed packages: update.packages(ask=FALSE, checkBuilt=TRUE) \" ${NL}\
\">> R: read from clipboard: y=data.matrix(read.delim(pipe(\\\"pbpaste\\\"))); \" ${NL}\
\">> R: install package from BIOCONDUCTOR without root: source('http://www.bioconductor.org/biocLite.R'); biocLite(lib=head(unlist(strsplit(Sys.getenv('R_LIBS'),':')),1), lib.loc=head(unlist(strsplit(Sys.getenv('R_LIBS'),':')),1), pkgs=c('PACKAGENAMEHERE')) \" ${NL}\
\">> R: install package from CRAN without root: install.packages(repos='http://cran.cnr.berkeley.edu/', dependencies=TRUE, lib=head(unlist(strsplit(Sys.getenv('R_LIBS'),':')),1), pkgs=c('PACKAGENAMEHERE')) \" ${NL}\
\" \" ${NL}\
\">> GZIP: verify files: for f in **/*.gz; do gunzip --test -v \\\$f ; done; \" ${NL}\
\">> Text: wrap lines at 80 chars, preserving/ignoring word boundaries: fold -w 80 -s text.txt (omit -s to cut words) \" ${NL}\
\">> Shell/bash: Redirect stdout/stderr separately: CMD > out.txt 2> err.txt \" ${NL}\
\">> Shell/bash: Pipe stderr (and stdout too): CMD 2>&1 | less -S \" ${NL}\
\">> Shell/bash: Modify variable: newV=\\\$(sed -e's/a/1/; s/b/2/; s/c/3/' <<< \\\$oldV) \" ${NL}\
\">> Shell/bash: Script run with ionice:  ionice -c3 -p\\\$\\\$ (top line of a /bin/sh script) \" ${NL}\
\">> Shell/bash: Rename files with parent directory in filename for f in DIRS*/file.whatever; do echo \\\$f \\\$(dirname \\\$f)/\\\$(dirname \\\$f).\\\$(basename \\\$f).whatever ; done \" ${NL}\
\">> Shell/bash: Rename files to NOT have the path in them at all: for fff in **/*.html ; do ggg=$(echo $fff | tr / _); mv $fff $ggg; done \" ${NL}\
\">> Shell/bash: Rename files to have unique names: for f in **/*fastqc.html; do /bin/cp \\\$f DESTINATION_DIR/\\\$(md5sum \\\$f | cut -d ' ' -f 1).\\\$(basename \\\$f); done \" ${NL}\
\">> Shell/bash: Rename files to a LIST of new names in a file: while read -u 9 SRC; do read -u 8 DEST; echo mv \\\"\\\$SRC\\\" \\\"\\\$DEST\\\"; done 9<<<\\\"\\\$(ls -1 * | grep -v NEW_FILENAME_LIST.txt)\\\" 8< NEW_FILENAME_LIST.txt \" ${NL}\
\">> Shell/bash: Check to see if dir is empty if [[ \\\"\\\$(ls -A $OUTDIR)\\\" ]]; then echo \\\"ERR: Output dir not empty!\\\"; exit 2; fi \" ${NL}\
\">> MD5 verify: md5sum -c md5*.txt. Checksum must be 1st col, then 2 spaces, then filename. If checksum is 2nd: cat md5*.txt | awk '{print \\\$2\\\"  \\\"\\\$1}' | md5sum -c \" ${NL}\
\">> HEX HEXDUMP: View individual bytes of a file in hex form: hexdump -C FILENAME \" ${NL}\
\">> AWK: sum numbers in column 1 of a file: cat FILE | awk '{ sum+=\\\$1} END {print sum}'\" ${NL}\
\">> HG: Mercurial: restore accidentally-locally-deleted file from repo: hg revert FILENAME \" ${NL}\
\">> HG: Mercurial: revert to previous version: hg revert FILENAME -r-2 (or -r-3 for two versions ago, etc) \" ${NL}\
\">> HG: Mercurial: show diff from last version: hg diff -c -1 (or -2, -3, etc.) \" ${NL}\
\">> HG: Mercurial: <push creates new remote heads> is fixed by doing hg pull first! \" ${NL}\
\">> GIT only get the last 1 revision (faster): git clone --depth=1 https://your-site-here/something.git \" ${NL}\
\">> GIT discard ALL local changes: git reset --hard origin/master \" ${NL}\
\">> GIT fix an HTTP repo to SSH: git remote set-url origin git@github.com:RepoNameHere/ProjName.git \" ${NL}\
\">> GIT see old version of file (example: ~4 = 4 revisons ago): git show HEAD~4:./some_file.txt \" ${NL}\
\">> GIT delete a REMOTE branch: git push origin --delete BRANCHNAME (not delete, surprisingly) \" ${NL}\
\">> GIT list files in a branch: git ls-tree -r -l BRANCHNAME \" ${NL}\
\">> GIT what changed between branches?: git diff --summary BRANCH1 BRANCH2 \" ${NL}\
\">> GIT GUI and 'when was a branch made from master': gitk --all --select-commit=\\\$(git merge-base YOURBRANCH master)  \" ${NL}\
\">> GIT when branch was last used (MINIMAL): for BRANCH in \\\$(git branch -r | grep -v 'HEAD'); do echo -e \\\$(git show --format='%ci %cr' \\\$BRANCH | head -n 1) \\\\\\\\t\\\$BRANCH; done | sort -r \" ${NL}\
\">> GIT when branch was last used AND last commit (fancy): git for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))' \" ${NL}\
\">> TERM: Get terminal width/height: tput cols  or  tput lines \" ${NL}\
\">> BACKUPS: Check for changed files of a certain name: grep -E '>f.' /it/backup/log/*.log | grep YOURNAME \" ${NL}\
\">> UNIX/FILE: Add filename to top of (copy of) files. for f in FILES*; do echo \\\$f | cat - $f > NEW_\\\$f ; done \" ${NL}\
\">>           ...or if you will later paste/join those: for f in SPLIT*.diff; do echo \\\$f | cat - \\\$f | table-no-ragged.py - > NEW_\\\$f; done \" ${NL}\
\">> UNIX: convert RELATIVE symlinks to ABSOLUTE PATHS: for fff in *; do FULL=\\\$(readlink -f \\\$fff); ln -sf \\\$FULL \\\$fff ; done \" ${NL}\
\">> UNIX: 1) double-dereference symlinks, showing their final targets: find -L . -type f -exec readlink -f {} \\\; \" ${NL}\
\">> UNIX: 2) double-dereference symlinks, showing their final targets: for f in * ; do echo -e \\\$f\\\"\\t\\\"\\\$(readlink -f \\\$f); done   \" ${NL}\
\">> UNIX: Just delete symlinks find DIRNAME/ -type l -delete \" ${NL}\
\">> UNIX: print orphaned/broken symlinks: find . -type l -exec sh -c \\\"file -b {} | grep -q ^broken\\\" \; -print \" ${NL}\
\">> UNIX: total file size for files with a certain extension (Here, jpg): find . -type f -iname '*.jpg' -print0 | du -ch --files0-from=- \" ${NL}\
\">> UNIX: list files w/modified time MORE THAN one week ago: find . -mtime +7 \" ${NL}\
\">> UNIX: list files w/modified time LESS THAN one week ago: find . -mtime -7 \" ${NL}\
\">> UNIX: list files w/modified time two days ago: find . -mtime 2 \" ${NL}\
\">> UNIX: list files w/modified time between 6 and 9 minutes ago: find . -mmin +5 -mmin -10 \" ${NL}\
\">> UNIX: list ONLY dot files, no .. or up a directory: ls -l .??* \" ${NL}\
\">> UNIX: set up symlinks from Mercurial/TimeForScience: ln -sfn ~/TimeForScience/Config/Alex_Williams/.??* ~/ \" ${NL}\
\">> UNIX: symlink executables: for f in \\\$(find PATH -maxdepth 1 -perm -111 -type f); do ln -s \\\$f ./; done \" ${NL}\
\">> UNIX: upgrade: sudo aptitude update && sudo aptitude safe-upgrade <-- more assertive than apt-get upgrade.\" ${NL}\
\">> UNIX: IO nice (low-priority): ionice -c2 -n7 -pPROCID <-- -n7: lowest non-idle priority. PROCID is the PID.\" ${NL}\
\">> UNIX: IO nice (lowest-priority): ionice -c3 -pPROCID  <-- -c3: IDLE priority; doesn't slow anyone else down.\" ${NL}\
\">> UNIX: IO nice for a user \\\$THEUSER: SSS=\\\$(ps -fu \\\$THEUSER | perl -pe 's/[ ]+/\t/g' | cut -f 2 | tail -n +2); for pid in \\\$SSS ; do echo 'PID' \\\$pid; sudo ionice -c3 -p \\\$pid ; sudo renice +10 -p \\\$pid; done\" ${NL}\
\">> UNIX: Find zombie processes: ps aux | awk '{ print \\\$8 \\\" \\\" \\\$2 }' | grep -w Z \" ${NL}\
\">> UNIX GREP: look for text from a file, like join: grep -w -f KEYFILE.txt search_in_file.txt \" ${NL}\
\">> UNIX GREP: filter files based on presence of text: mkdir YES NO; for f in *.txt; do if [[ \\\"\\\$(grep 'YOUR_STRING_HERE' \\\$f | wc -l)\\\" -ne \\\"0\\\" ]]; then mv \\\$f yes/; else mv \\\$f no/; fi ; done \" ${NL}\
\">> UNIX: Check Linux version: cat /etc/*-release \" ${NL}\
\">> UNIX: Set system time on Ubuntu: sudo ntpdate-debian \" ${NL}\
\">> UNIX: Rsync transfer files: rsync --dry-run -R -havz --progress --stats --bwlimit=999999 LOCALFILES USER@REMOTE.COM:/path/to/  \" ${NL}\
\">> UNIX: Password FTP command line Xfer: wget -r ftp://USERNAME:password@ftp.some.site.com/Somefiles \" ${NL}\
\">> UNIX/WGET/TRICKLE: Rate limit any command to 500kbps (-d = down, -u = up): sudo trickle -d 500 -u 500 ncftp 'your_ftp_site_here' \" ${NL}\
\">> UNIX: See why Ubuntu wants to restart:  cat /var/run/reboot-required.pkgs \" ${NL}\
\">> UNIX/TOP/USAGE/HTOP: CPU usage by user: top -b -n 1 -u \\\$USER | awk 'NR>7 { sum += \\\$9; } END { print sum; }' \" ${NL}\
\">> QSUB/QUEUE/PBS show available resources: pbsnodes -a , or qstat -Qf (per-queue amounts)\" ${NL}\
\">> QSUB/QUEUE/PBS submit job: echo 'echo \\\"hello I am a test job\\\"' | qsub -q Bio -W group_list=bioqueue ; sleep 10; cat STDIN*; \" ${NL}\
\">> QSUB/QUEUE/PBS: for j in \\\$${PAREN_OPEN}qstat -a | grep 'YOURNAME' | cut -d '.' -f 1); do echo \\\"qdel \\\$j...\\\"; qdel \\\$j ; done \" ${NL}\
\">> QSUB/QUEUE/PBS: restart torque: sudo service pbs_sched stop ; sudo service pbs_mom stop ; sudo service pbs_server stop ; sudo /bin/rm /var/lock/subsys/pbs_server ; sudo service pbs_sched start ; sudo service pbs_mom start ; sudo service pbs_server start ; qstat \" ${NL}\
\">> QSUB/QUEUE/PBS: info on the queue: qstat -Qf or qstat -B more details \" ${NL}\
\">> QSUB/QUEUE/PBS: qrun MULTIPLE jobs in a range: for f in \\\$(seq 119905 119919); do sudo \\\$(which qrun) \\\$f; done \" ${NL}\
\">> QSUB/QUEUE/PBS: kill all YOUR jobs: qselect -u \\\$USER | xargs qdel ; \" ${NL}\
\">> QSUB/QUEUE/PBS: see available nodes / available resources:  pbsnodes -a (summary) or pbsnodes -a -v (per 'socket') \" ${NL}\
\">> UNIX/DPKG/APT-GET: dpkg/apt-get woes? Try manually editing /var/lib/dpkg/info/YOURPACKAGE . Be careful! \" ${NL}\
\">> UNIX/DPKG/APT-GET: Check the version of an apt-get installed package:   dpkg -s <packagename>  OR   dpkg -l | grep -i <search_string> \" ${NL}\
\">> UNIX/YUM/RPM install: (this NEVER works, but): rpm -Uvh your.rpm . Does NOT handle dependencies.\" ${NL}\
\">> YUM list installed packages: yum list installed \\\"*perl*\\\"  <-- stars are important!    \" ${NL}\
\">> UNIX/APTITUTDE: sudo aptitude update && sudo aptitude safe-upgrade <-- more assertive than apt-get upgrade.\" ${NL}\
\">> UNIX/APT-GET: upgrade only EXISTING packages matching wildcard pattern: apt-get install --only-upgrade 'r-cran*' \" ${NL}\
\">> UNIX/APT-GET: Fix 'NO_PUBKEY *SOMEKEY*' in APT: gpg --keyserver subkeys.pgp.net --recv *SOMEKEY* ; gpg --export --armor *SOMEKEY* | sudo apt-key add - \" ${NL}\
\">> SSH without loading bashrc or bash_profile: ssh -t user@server bash --norc --noprofile \" ${NL}\
\">> SSH Passphraseless: Client: ssh-keygen -t rsa ; Append client ~/.ssh/id_rsa.pub   to server ~/.ssh/authorized_keys \" ${NL}\
\" \" ${NL}\
\">> ZIP: Zip a folder: zip -r ARCHIVENAME FOLDER \" ${NL}\
\">> BASH: Foreach/rename: for f in \\\$${PAREN_OPEN}ls); do echo \\\$f will become \\\$${BRACKET_OPEN}f/.txt/.newending} ; done \" ${NL}\
\">> PERL: redirect STDERR and STDOUT in backticks: my \\\$stderr_and_out = \\\`commandhere 2>&1\\\`; my \\\$exitCode = \\\$?; \" ${NL}\
\">> BASH: redirect STDERR & STDOUT both to console and to a file: THECMD 2>&1 | tee --append LOGFILE\" ${NL}\
\">> BASH: See a function definition: type FUNCTIONNAME \" ${NL}\
\">> BASH: Change tab width in bash:  setterm -regtabs 16 (16 = huge!) \" ${NL}\
\">> BASH: Expand tabs/tab width: something | expand -t 32 \" ${NL}\
\" \" ${NL}\
\">> BIOINF: Sort a GTF file:  LC_ALL=\\\"C\\\" sort -k 1,1 -k 4,4n YOUR.GTF > SORTED.GTF \" ${NL}\
\" \" ${NL}\
\">> Gnu parallel: works like xargs, but works with files with spaces, by default. \" ${NL}\
\">> XARGS/FIND multiple commands: find . -name SOMEFILE -print0 | xargs -0 -I {} sh -c \\\"echo {}; thing {} | piped here | wc -l ; \\\"  \" ${NL}\
\">> XARGS/FIND: bzip all the bed/diff/count files that you can find: find . -type f \( -iname \\\"*.bed\\\" -o -iname \\\"*_tracking\\\" -o -iname \\\"*.diff\\\" -o -iname \\\"*.moa\\\" -o -iname \\\"*.fasta\\\" -o -iname \\\".fa\\\" -o -iname \\\"*.bed.count\\\" \) -print0 | xargs -0 bzip2 \" ${NL}\
\">> CHMOD Make files readable, directories r+x (print0/-0 makes filenames with spaces work): sudo chmod -R a+r ./ ; sudo find ./ -type d -print0 | sudo xargs -0 chmod a+x   (this is the command 'sudoshowoff')\" ${NL}\
\">> GNU FIND and DELETE a file (dangerous): find . -name SOMEFILE -delete \" ${NL}\
\">> UNIX/Perl fast sort with ONE header line: cat FILE | perl -e 'print scalar (<>); print sort <>' > OUTFILE \" ${NL}\
\">> Perl: REGEXP multi-line search/replace: perl -00pe 's{thing1}{thing2}gxms' THE_FILE  <-- s lets '.' match newlines\; m makes ^ and \\\$ work \" ${NL}\
\">> Perl: replace IN PLACE in a file, with backups for \\\$file in FILES; do perl -p -i.bak -e 's/STRING_TO_REPLACE/NEW_STRING/g' \\\$file; done  \" ${NL}\
\">> Perl/web: Chrome web form non-breaking space (ASCII 160) is [\\xA0] (or 'use feature qw(unicode_strings);') \" ${NL}\
\">> Perl: CPAN invocation: sudo perl -MCPAN -e shell \" ${NL}\
\">> Perl: CPAN upgrade all WITHOUT prompting: PERL_MM_USE_DEFAULT=1 && sudo perl -MCPAN -e shell >> then o conf build_requires_install_policy yes  ; o conf prerequisites_policy 'follow'  ; o conf commit ;  upgrade /(.\\*)/\\\" \" ${NL}\
\">> Perl: Backreferences/does something show up twice on a line: perl -n -e 'print ((\\\$_ =~ /\b(Something\d+)\s.\g1/) ? qq{match: \\\$1\\n} : qq{Nope\\n});' \" ${NL}\
\">> EMACS: insert newline in search-and-replace:  Ctrl-Q Ctrl-J \" ${NL}\
\">> EMACS: install new packages: list-packages \" ${NL}\
\">> EMACS: show variable: describe-variable \" ${NL}\
\" \" ${NL}\
\">> Convert SAM to BAM with QPLZ:  for SSS in **/*.sam; do qplz --background \\\"samtools view -bS \\\$SSS > \\\${SSS/.sam}.bam\\\" ; done \" ${NL}\
\">> FASTA remove linebreaks from sequence: cat file.fasta | awk '!/^>/{printf \\\"%s\\\", \\\$0; n=\\\"\n\\\"} /^>/{print n \\\$0; n=\\\"\\\"} END {printf\\\"%s\\\",n}' > out.fa \" ${NL}\
\">> SEQ: fastq2fasta (fq2fa, fastq -> fasta): zcat FQ.fq.gz | awk '{if(NR%4==1) {printf(\\\">%s\n\\\",substr(\\\$0,2));} else if(NR%4==2) print;}' > FASTA.fa \" ${NL}\
\">> SEQ: bcl2fastq: NCPU=4; bcl2fastq --fastq-compression-level 5 --barcode-mismatches 1 --no-lane-splitting -r $NCPU -d $NCPU -p $NCPU -w $NCPU --sample-sheet 'THIS_MUST_BE_VALID_NOT_MAC_FORMAT.csv'  --runfolder-dir=WEIRDLY_NAMED_160_NB01415_ABCDQBXX   (output goes to Data/Intensities/BaseCalls/*.fastq.gz) \" ${NL}\
\">> FASTQ/FASTA subsample 500 reads randomly. Use -s1234 (random seed) so you can get the same reads in paired-end situations: seqtk sample -s1234 read1.fq.gz 500 | gzip > sub1.fq.gz \" ${NL}\
\">> RNASEQ SAM --> BAM:  samtools view -bS in.sam > out.bam \" ${NL}\
\">> RNASEQ BAM --> SAM:  samtools view -h  in.bam > out.sam \" ${NL}\
\">> RNASEQ samtools view first read of pair only:  samtools view -f  64 file.bam \" ${NL}\
\">> RNASEQ samtools view second read of pair only: samtools view -f 128 file.bam \" ${NL}\
\">> RNASEQ sorting and setting the 'sorted' flag:  java -Xmx2g  -jar SortSam.jar INPUT=in.sam SORT_ORDER=coordinate OUTPUT=out_sorted.sam \" ${NL}\
\">> RNASEQ View BAM header: samtools view -H  in.bam \" ${NL}\
\">> RNASEQ Merge BAM files in subdirectories: for f in * ; do samtools merge \\\${f}_merged.bam \\\$f/*.bam; done \" ${NL}\
\">> RNASEQ arbitrary text filtering in Perl on a BAM file: samtools view -h in.bam | perl -ne 'if (m/^@/) {print;} else { print if m/YOURCONDITIONHERE/; }' | samtools view -bS > filtered.bam  \" ${NL}\
\">> RNASEQ remove non-primary and non-aligned reads: samtools view -b -F 0x104 in.bam > mapped_primary.bam \" ${NL}\
\">> RNASEQ count primary (0x100) mapped (0x4) reads: samtools view -c -F 0x104 in.bam > COUNT.txt\" ${NL}\
\">> RNASEQ Count frequencies of first 5 bases of a SAM file: cut -f 10 theFile.sam | cut -c 1-5 | sort | uniq -c \" ${NL}\
\">> RNASEQ TOPHAT/rename TEST: for f in *; do echo \\\${f}/accepted_hits.bam \\\${f}/accepted_hits_\\\${f}.bam ; done \" ${NL}\
\">> RNASEQ TOPHAT/rename RUN : for f in *; do   mv \\\${f}/accepted_hits.bam \\\${f}/accepted_hits_\\\${f}.bam ; done \" ${NL}\
\">> RNASEQ: Truncate a fastq file to length 19 without using fastx-trimmer: awk 'NR % 2 == 0 { \\\$0=substr(\\\$0,1,19)} {print}' \" ${NL}\
\">> Obtain SRA sequence from NCBI: prefetch --verbose SRR__whateverID__ \" ${NL}\
\">> SRA->FASTQ: fastq-dump --gzip SRR1234.sra    (<-- creates new file 'SRR1234.fastq.gz') \" ${NL}\
\">> MINION LONG READ SEQ: FAST5 to FASTQ: Make a single FASTQ out of all FAST5s in each of the 'barcode' subdirectories (assumes the file structure is: minion/barcode01/batch9988/file.fast5): for bar in barcode*; do final=ToFQ.\\\$bar.final.fq.gz; /bin/rm -f \\\$final; for f in \\\${bar}/*/*.fast5; do echo 'Handling'\\\$f; poretools fastq \\\$f | gzip >> \\\$final; done; done \" ${NL}\
\">> BLAST: DNA pair-wise similarity for all sequences in a fasta file:   makeblastdb -in REF.fa -db nucl  &&  blastn -outfmt 6 -db REF.fa -query REF.fa -out results.out \" ${NL}\
\">> BLAST: extract DATABASE sequences back to FASTA: In the directory with database files starting with the prefix 'nt_your_prefix_whatever', blastdbcmd -db nt_your_prefix_whatever -entry all -out - | gzip > all_sequences.fasta  \" ${NL}\
\">> DNA reverse-complement: perl -e '\\\$x = qq{AAAA_SEQUENCE_GGGG_TT_CC}; \\\$_ = scalar(reverse(\\\$x)); tr/ACGT/TGCA/; print \\\$_;' \" ${NL}\
\">> APACHE error log: sudo less -S /var/log/apache2/error.log \" ${NL}\
\">> MacOS DNS woes: sudo dscacheutil -flushcache \" ${NL}\
\">> MacOS Dictionary: /usr/share/dict/words \" ${NL}\
\">> MacOS why isn't the screensaver working: pmset -g (see 'sleep' in there), then pmset -g assertions \" ${NL}\
\">> MacOS Image type convert: mkdir -p PNGS_TO_JPEG; sips -s format jpeg *.png --out PNGS_TO_JPEG \" ${NL}\
\">> COPROC: coproc: re-run a command every 19 seconds: for i in {1..50} ; do coproc { ls >> myfile.tmp ; } ; sleep 19; kill \\\$COPROC_PID ; sleep 2; done \" ${NL}\
\">> LINES: RANDOM subset (0.5 = 50%, 0.1 = 10%, etc):  perl -ne 'print if (rand() < 0.5);' theFile.txt \" ${NL}\
\">> LINES: REPEATABLE RANDOM subset: perl -e 'srand(123456); while(<>){ print if (rand() < 0.5);}' theFile.txt \" ${NL}\
\">> LINES: Semi-random FASTA records (2 lines at a time): perl -e 'my \\\$total=0; my \\\$MAX=3; srand(); while(<>){ if (rand()<0.01) { print \\\$_; my \\\$nextLine=<>; print \\\$nextLine; \\\$total++; exit(0) if (\\\$total>=\\\$MAX); } }' \" ${NL}\
\">> LINES: Range from N to M, inclusive (starts at 1):  sed -n N,Mp INPUTFILE  or  for a HUGE file: sed -n '(N+1)q;N,Mp' <-- quit on line (N+1) \" ${NL}\
\">> LINES: Every Xth, starting with line Y (starts at 1, not 0): awk 'NR%X==Y' FILE (FASTQ example: sequences only is 'NR%4==2')\" ${NL}\
\">> LINES/AWK: Count num columns in file: awk -F '\t' '{print NF}' \" ${NL}\
\">> LINES based on perl expr: perl -e '\\\$n = 0; while(<>) { if (\\\$n%2 == 0) { print \\\$_; }; \\\$n++; }' \" ${NL}\
\">> LINES Count chars on each line: cat FILENAME | awk '{print length(\\\$0)}' \" ${NL}\
\">> AWK: Get only FIRST line with a unique occurrence in column 1. Does not require sorting: cat FILE | awk -F'\\t' '!_[\\\$1]++' (assumes separator is tab) \" ${NL}\
\">> GREP Count occurrences of a match per line: cat FILE | grep -o -n SEARCHTERM | cut -d : -f 1 | uniq -c \" ${NL}\
"

# Shell navigation/commands

#pushd() { builtin pushd "$@" > /dev/null; } ## <-- make it so that pushd doesn't print the stack every single time

#hasExa=agw_cmd_exists "exa"

#if [[ "$hasExa" && "$isMac" ]]; then # check for 'exa' -- the 'ls' replacement, but only on the Mac---it's slow on Rigel!

#LS_MAX_ENTRIES=200
#alias l2='echo -e "$(exa --color=always)"'
if agw_cmd_exists "exa" && [ "$isMac" == "1" ] ; then
    # 'exa' is a 'ls' replacement
    alias ls='exa --color=auto'
    alias ll='exa -l -a --color=auto'
elif agw_cmd_exists "exa" ; then
    # Not the mac, I guess??
    alias ls='exa --color=auto'
    alias ll='exa -l -a --color=auto'
else
    if [[ "$color_prompt" && "$isMac" ]]; then
	AGW_LS_OPT=' -F -G ' #-@ ' ## Mac: Color option is -G. Also, on a Mac, show the extended attributes (-@)
    elif [[ "$color_prompt" && (-z "$isMac") ]]; then
	AGW_LS_OPT=' --indicator-style=slash --color=auto ' ## Ubuntu: color is --color=auto
    else
	AGW_LS_OPT=''
    fi

    if [[ "$isMac" ]]; then
	AGW_MACEXT=' -@ ' # Mac extended attributes
    else
	AGW_MACEXT=' '
    fi
    
    alias ls="/bin/ls               ${AGW_LS_OPT} "
    alias ll="/bin/ls   -l -h -A -F ${AGW_LS_OPT} "
    alias lmac="ll ${AGW_MACEXT} " # mac-specific with EXTENDED attributes (-@)
fi

alias l='ls'
alias lo='ll -r -t' # Depends on "ll" already being defined above. List by TIME so that NEWEST files are at the bottom
alias p='pwd -P'

alias c='cd'
alias ..='cd ..'
#alias ../='cd ..'
#alias ../../='cd ../../'

#alias ..='pushd ..'
alias res='source ~/.bashrc ; source ~/.bash_profile'
alias mv='mv -i'
alias cp='cp -i'
alias kpk='exit'

alias diffdir='diff -rq' ## diff on directories

# Turn on/off crashplan. No longer necessary.
#alias recrash='sudo launchctl unload /Library/LaunchDaemons/com.crashplan.engine.plist; sleep 1; sudo launchctl load /Library/LaunchDaemons/com.crashplan.engine.plist'

#alias tc='randomize_terminal_color.pl -cycle'
#alias cd='pushd'
#alias b='popd'

## "showoff" makes it so that everyone can a+rx any directories and a+r any files.
## Note that we don't want to make it so everyone can execute *files* necessarily, just folders
## ("Executing" a folder means you can "ls" it and see what's inside.)
function showoff {
    if [ "$#" -eq 0 ]; then echo "Usage: 'showoff' requires path argument(s)! Example: 'showoff ./' for the current directory."; return; fi
    for var in "$@"; do echo "showoff is now running 'chmod -R' to allow ANY USER to browse \"$var\""; chmod -R a+rX "$var"; done
}
function sudoshowoff {
    if [ "$#" -eq 0 ]; then echo "Usage: 'sudoshowoff' requires path argument(s)! Example: 'sudoshowoff ./' for the current directory."; return; fi
    for var in "$@"; do echo "sudoshowoff: Using sudo chmod -R to allow ANY USER to browse \"$var\""; sudo chmod -R a+rX "$var"; done
}

## Mac-specific commands:
SETFILE_LOCATION=/Applications/Xcode*/Contents/Developer/Tools/SetFile
alias invisible='chflags -h hidden'  #alias invisible='chflags hidden' #$SETFILE_LOCATION -P -a V' ## Mac-only: Make a file/folder invisible to the Finder
alias visible='chflags -h nohidden' #alias visible='chflags nohidden' #$SETFILE_LOCATION -P -a v' ## Mac-only: opposite of "invisible"
alias clearicon='$SETFILE_LOCATION -P -a c' ## clear mac custom icons. Useful for images that have old custom icons.
alias version="lsb_release -a" # Tells you which version of Ubuntu you are running!

function mac2unix { # Convert a Mac-style line-ending file to a UNIX one. Useful for when you save a file in Excel and then UNIX won't read it.
    if [[ -f "$1" ]] ; then cat "$1" | tr '\r' '\n' ## if a filename is passed in, then auto-cat that file
    else tr '\r' '\n' ; fi ## otherwise it's probably part of a cmdline pipe
}

function dos2unix { # Convert a Windows-style line-ending file to a UNIX one. Useful for when you save a file in Excel and then UNIX won't read it.
    if [[ -f "$1" ]] ; then cat "$1" | tr -d '\r' ## if a filename is passed in, then auto-cat that file
    else tr -d '\r'; fi ## otherwise it's probably part of a cmdline pipe
}

## Utility commands

## -U: "screen understands UTF8"
alias rr='tmux attach || tmux new' #"screen -xR -U" ## Reconnect to the previous screen, or make a new one if there isn't one already
alias sc='tmux new-window' #'screen' ## Make a new screen session

alias wcl='grep -c ""' # actually gives you the NUMBER and not the filename
alias sortt='sort -t "	"' # sort with tab as separator
alias sortg='sort -g -t "	"' # sort NUMBERS, with tab as separator

#if [[ -f /usr/local/bin/emacs ]]; then
#if [[ -n "$isMac" ]]; then
#    alias e='emacs --no-splash -nw ' # use 'brew install emacs' to update emacs
#else
alias e="emacsclient -nw  -c --alternate-editor=\"\"" # "As a special exception, if command is the empty string, then emacsclient starts Emacs in daemon mode (as emacs --daemon) and then tries connecting again."
#alias e2="LANG='en_US.UTF-8' bash -c 'emacsclient -nw  -c --alternate-editor=\"\"'" # "As a special exception, if command is the empty string, then emacsclient starts Emacs in daemon mode (as emacs --daemon) and then tries connecting again."
#fi

#alias t='transpose.pl -q'
alias tattle="echo -e -n '$a_status_color'; ps aux | tail -n +2 | sort --reverse -k 3,3 | head -n 5 | perl -p -e 's/[ ]+/\t/g' | cut -f 1,3,4,11 | cap.pl 'USER,CPU,MEM,TASK' | sheet.pl --color=always \
--ht=75 --trunc=60 | tail -n +2 ; echo -e -n '$a_end_color'"

# GNU Make-related
alias make='make --warn-undefined-variables --print-directory'
alias mcm='make clean && make'
function remake { ## Lets you type "remake" to remove a file and then use GNU make to try to re-generate it
    trash.pl "$@" ;  make --warn-undefined-variables --print-directory "$@"
}

function rel { ## Remake and then view;
    trash.pl "$@" ;  make --warn-undefined-variables --print-directory "$@" ; s "$@"
}

# Aliases related to COLOR GREP
alias grepi='grep   -i' # <-- runs fast if "LANG=C" is the specified language
alias grepc='grep   --color=always --with-filename --line-number'
alias egrepc='egrep --color=always --with-filename --line-number'
alias fgrepc='fgrep --color=always --with-filename --line-number'

# Aliases related to CVS
alias commit="cvs commit -m 'AGW CVS Commit'"
alias gitcom="git commit -a -m 'Changes committed by alexgw'"
alias gitstat="git ls-files --modified --deleted"
alias gitdiff="git difftool"

alias hgcom="hg commit -u '${USER}' -m 'Changes committed by ${USER}' && echo '[Done] committing changes locally with Mercurial.'"
alias hgpush="hg commit -u '${USER}' -m 'Changes committed by ${USER}' && hg push && echo '[Done] pushing changes to the remote server with Mercurial.'"
alias hgpull="hg pull ; hg update && echo '[Done] pulling remote changes and updating the local Mercurial repository.'"
alias hgup="hg update -v && echo '[Done] updating local changes in Mercurial'"
alias hgs="echo '[hg status]:'; hg status; echo '[hg status --rev .:tip]:'; hg status --rev .:tip ; echo 'Note: to see every little detail, type \"hg log --patch -r .:tip\"' "

function hglog {
    hg status
    if [[ $? == "0" ]] ; then  ## <-- only check the log if there is actually a mercurial repo here!
	hg log -p --color=always "$@" | s
    fi
}

function sciencecom {
    if [[ -d "$1/.git" ]] ; then
	echo "Committing GIT changes locally."
	#cd "$1" ; git commit -a -m "Committing changes from ${USER}" ; git push origin master ;
	git --git-dir="$1/.git" --work-tree="$1" commit -a -m "Committing changes from ${USER}"
	echo "Pushing GIT changes to remote master."
	git --git-dir="$1/.git" --work-tree="$1" push origin master ;
    else
	echo "No $1 git repository exists on this machine."
	return 1;
    fi
}

function scienceup {
    if [[ -d "$1/.git" ]] ; then
	echo "Committing any local GIT changes before syncing with remote master."
	git --git-dir="$1/.git" --work-tree="$1" commit -a -m "Committing any local changes from ${USER} before sync with remote server." ;
	echo "Pulling GIT changes from remote master."
	git --git-dir="$1/.git" --work-tree="$1" pull ;
	#cd "$1" ; git --git-dir "$1" commit -a -m "Committing any local changes from ${USER} before sync with remote server." ; git --git-dir "$1" pull ;
    else
	echo "No $1 git repository exists on this machine."
	return 1;
    fi
}

function science {
    if [[ -e "${TIME_FOR_SCIENCE_DIR}" ]]; then
       echo 'TimeForScience (GitHub):' ; scienceup ${TIME_FOR_SCIENCE_DIR} && sciencecom ${TIME_FOR_SCIENCE_DIR}
    fi
    if [[ -e "${HOME}/epi" ]]; then
	echo '~/Epi (GitHub):' ; scienceup ${HOME}/epi && sciencecom ${HOME}/epi
    fi
    #echo 'Bioinformatics (Git on Westway):' ; scienceup ${BINF_CORE_WORK_DIR} ; sciencecom ${BINF_CORE_WORK_DIR}
    echo -e '\nFinished updating on' `date`
}

AGW_SSH_OPTIONS=" -o ServerAliveInterval=30 -C "

alias nami=' ssh ${AGW_SSH_OPTIONS} -i ~/Dropbox/metaquery-dev.pem bitnami@52.53.252.164'

alias nau=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${BN_IP}'  # From the not-uploaded file /work/Code/alexgw/aliases-server-config (or .aliases-server-config in the home directory!)
alias naux='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${BN_IP}'
alias bus=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${BC_IP}'
alias busx='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${BC_IP}'
alias wes=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${WES_IP}'
alias wesx='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${WES_IP}'

alias rig=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${RIG_IP}'
alias rigx='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${RIG_IP}'

alias beef='ssh ${AGW_SSH_OPTIONS} -i ${BEEFY_PEM} ${BEEFY_U}@${BEEFY_IP}'

alias agwcom='ssh ${AGW_SSH_OPTIONS}   ${AGWCOM_USERNAME}@${AGWCOM_URL}'

RIG_SAND_IP=${RIG_IP/./-sandbox.} # add "-sandbox" before the first dot
alias sand=' ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${RIG_SAND_IP}'

alias lig=' ssh ${AGW_SSH_OPTIONS}     ${PL_USERNAME}@${PL_IP}' # <-- LIG = different username!
alias ligx='ssh ${AGW_SSH_OPTIONS} -Y  ${PL_USERNAME}@${PL_IP}' # <-- LIG = different username!

alias bue=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${PB_IP}'
alias buex='ssh ${AGW_SSH_OPTIONS} -Y  ${ACC_U}@${PB_IP}'
alias che=' ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${CLUS_IP}'
alias newv='ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${NEWV_IP}'
alias tuck='ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${PS_IP}'

alias oso='ssh ${AGW_SSH_OPTIONS}     ${ACC_U}@${OSO_IP}'
alias osox='ssh ${AGW_SSH_OPTIONS} -Y ${ACC_U}@${OSO_IP}'

## LESS +++++++++++++++++
export PAGER=less
[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)" # make "less" friendly for non-text input files
export LESSOPEN="|${TIME_FOR_SCIENCE_DIR}/Config/1_Shell_Config/lesspipe_basic.sh %s"
# lesspipe_basic.sh casues less to transparently decompress gzipped files before showing them. Old:  '|/usr/bin/lesspipe.sh %s'
alias magicless='env LESSOPEN="|${TIME_FOR_SCIENCE_DIR}/Config/1_Shell_Config/lesspipe_advanced.sh %s" /usr/bin/less -S --RAW-CONTROL-CHARS -f --IGNORE-CASE'
# It's less, but it "magically" handles gzipped files and automatically runs ".tab" files through sheet.pl
# Note that this only magically happens if the files are passed in on the command line--otherwise you have
# to use "ssf" to force sheet.pl to be run (if a file is passed through a pipe, then it won't be run through
# sheet.pl unless you say "cat something | ssf"
## LESS +++++++++++++++++

# Plain "sn" doesn't run anything through sheet.pl, but it *does* handle gzipped files
alias sn='/usr/bin/less -S --LINE-NUMBERS --status-column --RAW-CONTROL-CHARS -f --IGNORE-CASE'

alias sweep='trash.pl *.tmp *.temp' ## Sweep out the .tmp files

alias htop='htop --sort-key PERCENT_CPU'

function playnicely {
    # Takes one argument.
    # requires sudo privileges. Takes one argument, the username to make play nicely:
    # example: playnicely THEUSERNAME
    SSS=$(ps -fu "$1" | perl -pe 's/[ ]+/\t/g' | cut -f 2 | tail -n +2);
    for pid in $SSS ; do echo 'ionice-ing and nice+15-ing process ID' $pid; sudo ionice -c3 -p $pid ; sudo renice +15 -p $pid ; done 
}

function disknicely {
    # Takes ZERO arguments. Just for making the 'nfsd' processes less annoying.
    SSS=$(ps -eopid,uid,cmd | grep "nfsd" | grep -v "grep" | perl -p -e "s/^[ ]+//" | cut -d " " -f 1) # Get any 'nfsd' processes
    for pid in $SSS ; do echo 'ionice-ing and nice+15-ing the NFS process ID' $pid; sudo ionice -c3 -p $pid ; sudo renice +15 -p $pid ; done 
}


function acol {
    column -s $'\t' -t # columns delimited by tabs! Like 'sheet.py'
}

function s { ## <-- this needs to come BEFORE the other things that use less!
    # "s" uses "magicless" to run files through sheet.pl
    magicless --LINE-NUMBERS --status-column "$@"
}

function acols {
    s "$@" | acol | s # Pipe it through magicless, then 'acol', then magicless AGAIN. Like a poor man's sheet.py (way faster, though)
}

function sf {
    # Forces sheet.pl to be called ("SS Force sheet.pl").  Can only view ONE file, unlike "ss"
    /usr/bin/less --RAW-CONTROL-CHARS "$1" | sheet.pl --color=always | s
}

function s1 {
    # like sf, but shorter columns # Can only view ONE file, unlike "s"
    /usr/bin/less --RAW-CONTROL-CHARS "$1" | sheet.pl --color=always --trunc=15 | s
}

function s2 {
    # like sf, but shorter columns # Can only view ONE file, unlike "s"
    /usr/bin/less --RAW-CONTROL-CHARS "$1" | sheet.pl --color=always --trunc=25 | s
}

function v {
    # Use sheet.py to view a file or list of files. These files cannot be gzipped, however.
    # Must be python2.6, and not python 3, currently
    python `which sheet.py` "$@"
}

alias huh='cat <(declare -f) <(alias)' ## uses bash subshells to show everything that is defined
alias backoff='${TIME_FOR_SCIENCE_DIR}/Config/Alex_Williams/unix_scripts/crashplan-backup-mod.sudo.sh off'
alias backon='${TIME_FOR_SCIENCE_DIR}/Config/Alex_Williams/unix_scripts/crashplan-backup-mod.sudo.sh on'

function n { # show colors
    echo -e  "$color_prefix[30m black $color_prefix[31mred $color_prefix[32mgreen $color_prefix[33myellow $color_prefix[34mblue $color_prefix[35mmagenta $color_prefix[36mcyan $color_prefix[37mwhite"
}

## Maczip zips things on the mac WITHOUT including the dot files and .DS_Stores
function maczip {
    if [[ "$#" == 1 ]] ; then theCompressedBasename="$1"; ## If you pass it one argument, then that argument will also be the filename
    else theCompressedBasename="Archive_zipped_without_Mac_files";
    fi
    theCompressedBasename=`echo "$theCompressedBasename" | sed "s/[/]//"` ## Let's remove any slashes from the name of the *output*. That way if someone types "mini MyDir/" it will generate "MyDir.zip" and NOT "MyDir/.zip"
    if [[ -f "${theCompressedBasename}.zip" ]] ; then
	echo "mini: HALTING: Cannot create a new archive---perhaps ${theCompressedBasename}.zip already exists.\nThis is forbidden--you cannot create the archive to overwrite the current archive!!! Delete it and compress again." ;
	return ;
    else
	if [[ "$#" -gt 1 ]] ; then echo "Adding a total of $# files to the new zip archive, which OMITS Mac-specific files (e.g. .DS_Store)." ; fi
	for var in "$@"; do echo " * Archiving $var --> ${theCompressedBasename}.zip" ; done
	echo "[ZIP] command running now..." ;
	zip -9 -r -X --symlinks --exclude "*.DS_Store" --exclude="*~*" --exclude="*\$*" "${theCompressedBasename}.zip"  $@;
	echo "[Done]" ;
    fi
}


function xztar {
    # Tar and xzip in one place so you don't have to remember the syntax. Yeah, or you could just remember the syntax!
    if [[ "$#" != 1 ]]; then echo "xztar can only accept ONE argument! One directory or file to tar/xz."; exit 1; fi
    OUTNAME=$(basename $1).tar.xz
    echo "Note that xztar is incredibly slow! So be prepared for it to take forever. Creating this archive: $OUTNAME"
    time tar --xz -cvf "$OUTNAME" "$1"
}

## Mini is a function that creates a .bz2 archive of whatever you pass into it.
## It works in a manner similar to right-clicking and zipping a file on the Mac.
## If you just pass it in ONE file named FILE, then the output filename is "FILE.tar.bz2" .
## If you give it multiple files, the output is in Archive.tar.gz
## To extract a "mini" archive, use "unmini" .
# Bugs: it ONLY WORKS IN THE CURRENT DIRECTORY! And it probably hates whitespaces.
# maybe this will help with escaping? for f in `ls`; do printf "%q " $f; done
# looks like 'printf' can save the day
function mini {
    [[ "$#" == 1 ]]         && compressedBasename="$1" || compressedBasename="Archive" ## If you pass it one argument, then that argument will also be the filename
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD/Mac, so check for it

    # xz is 10 times slower than bz2 to compress, but can be ~30% smaller for text.
    # xz is FASTER to decompress than bzip2, and is nearly the same as gzip.
    
    compressedBasename=`echo "$compressedBasename" | sed "s/[/]//"` ## Let's remove any slashes from the name of the *output*. That way if someone types "mini MyDir/" it will generate "MyDir.tar.bz2" and NOT "MyDir/.tar.bz2"
    if [[ $(tar --version) =~ .*bsdtar.* ]]; then TAREX=" -c -v "      # BSD tar
    else TAREX=" --preserve-permissions --atime-preserve -c -v "; fi   # GNU tar
    if [[ -f "${compressedBasename}.tar" || -f "${compressedBasename}.tar.bz2" ]] ; then
	echo "mini: HALTING: Cannot create a new archive---either ${compressedBasename}.tar or ${compressedBasename}.tar.bz2 already exists.\nThis is forbidden--you cannot create the archive to overwrite the current archive!!! Delete it and compress again." ;
	return ;
    else
	if [[ "$#" -gt 1 ]] ; then echo "Adding a total of $# files to the archive." ; fi
	for var in "$@"; do echo " * Archiving $var --> ${compressedBasename}.tar.bz2" ; done
	echo "[TAR] command running now... maybe should use 'xz' instead of bzip" ;
	eval "$AGW_IONICE" tar "$TAREX" --bzip2 -f "${compressedBasename}.tar.bz2" $@;
	echo "[Done]" ;
    fi
}

## Extracts any number of compressed files of ANY type. Usage: 'unmini a.bz2 b.tar.gz c.tar.bz2 ... etc...'
function unmini {
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD/Mac, so check for it
    if [[ $(tar --version) =~ .*bsdtar.* ]]; then TARPARAM=" -x -v "                 # BSD tar
    else TARPARAM=" --preserve-permissions --atime-preserve --keep-old-files -x -v "; fi # GNU tar
    NEVER_OVERWRITE_ZIP=" -n "
    for fff in "$@"; do # Loop through all the input arguments
	echo " * Decompressing \"$fff\"..."
	case "$fff" in 
	    *.tar.gz)  EX_CMD="tar $TARPARAM --ungzip -f  $fff" ;; 
	    *.tar.bz2) EX_CMD="tar $TARPARAM  --bzip2 -f  $fff" ;;
	    *.tar.xz)  EX_CMD="tar $TARPARAM     --xz -f  $fff" ;; 
	    *.tar)     EX_CMD="tar $TARPARAM          -f  $fff" ;;
	    *.xz)      EX_CMD="xz    --decompress         $fff" ;; 
	    *.gz)      EX_CMD="gzip  --decompress         $fff" ;; 
	    *.bz2)     EX_CMD="bzip2 --decompress         $fff" ;;
	    *.zip)     EX_CMD="unzip $NEVER_OVERWRITE_ZIP $fff   -d ${fff/.zip/}" ;;
	    *) echo "unmini has failed to detect type of archive (filename is <$fff>. Recommendation: make sure that file exists)... aborting." ; return ;;
	esac
	eval "$AGW_IONICE" "$EX_CMD" # <-- actually decompress the file
    done
}

alias snake="echo -n $'\xF0\x9F\x90\x8D'' '"  # Emoji snake. See http://apps.timwhitlock.info/emoji/tables/unicode
alias cake="echo  -n $'\xF0\x9F\x8D\xB0'' '"  # Emoji cake.  See http://apps.timwhitlock.info/emoji/tables/unicode

function qkiri { # kill all your OWN jobs
    echo ">> If qkiri fails, try running this command: qselect -u YOURNAME | sudo xargs qdel -p"
    echo "Do you REALLY REALLY want to completely cancel LITERALLY EVERY SINGLE ONE OF YOUR JOBS? ALL OF THEM???"
    select yn in "Wrong! Cancel! Keep these jobs!" "Delete--yes, kill ALL of my jobs without regret!"; do
	case $yn in
	    Wrong*)  echo "Cancelled!"; break;;
	    Delete*) qselect -u $USER | xargs qdel ; echo "[Cancelled jobs]"; sleep 1; qstats; break ;;
	esac
    done
}

# grep 'pattern' can also be replaced with: perl -nle "print if m{PATTERN}" # <-- beware of '$1' versus "$1" issues!

function qstatlong { # show qstat with LONG (full) job names:
    qstat -f | egrep -i '(Job Id|Job_Name|Job_Owner|job_state|list.walltime)' | perl -pe 's/(.*Job_Owner.*)@.*/\1/i' | perl -pe 's/.*=\s//' | perl -pe 's/\n/\t/g' | perl -pe 's/(Job Id:\s|$)/\n/ig' | grep -v '^$'
}

function qsass { # kill all jobs that match this grep... works for usernames, jobs, etc. Be careful!
    # Example usage:  qsass    yourname             # Hopefully yourname is not a subset of someone ELSE's name!
    # or:             qsass    test_job_number_     # Uses GREP, so watch out for invalid regexps!
    #sudo echo 'Initializing sudo permissions here'
    if [[ ${#1} -lt 4 ]]; then
	echo "ERR: Your argument to qsass ($1) was not long enough (it is only length ${#1})---it needs to be at least 4 characters, or else we don't believe it's a valid input! Be careful! Even PARTIAL MATCHES will trigger the job deletion. So don't delete 'bad_job' if you don't also want to delete 'not_a_bad_job'."
	return 1;
    fi;
    echo "Trying to use qdel to delete jobs that match '$1'...";
    IFS=$'\n' # <-- split a bash string on NEWLINES and not spaces!
    DELETE_US=()
    for jobtext in $(qstatlong | perl -nle "print if m{$1}"); do
	jobid=$(echo "$jobtext" | cut -d '.' -f 1)
	echo "Found a job ID to delete that matched '$1': $jobid (\"$jobtext\")";
	DELETE_US+=("$jobid")
    done
    echo "If you really want to DELETE those jobs, input a '2'."
    select yn in "Wrong! Keep these jobs!" "Delete these jobs from the queue!"; do
	case $yn in
	    Wrong*)  echo "Cancelled!"; break;;
	    Delete*) for j in "${DELETE_US[@]}"; do echo "Deleting job ID $j..."; `which qdel` $j ; done; break;;
	esac
    done
}

function checkbackup {
    # checks the MOST RECENT file in /it/backup/log, and gives you the last 10 lines from that file
    echo ""
    echo "Reporting the last 10 lines of the most recent backup on this machine."
    echo "If these lines are not from yesterday or today's date, then something is seriously wrong!"
    tail -n 10 /it/backup/log/$(ls -1t /it/backup/log/ | head -n 1)
    TODAY=$(date +"%Y%m%d")
    YESTERDAY=$(date +"%Y%m%d" --date='1 day ago')
    LAST_BACKUP_DATE=$(ls -1t /it/backup/log/ | head -n 1 | cut -f 1 -d '-')
    [[ ("$LAST_BACKUP_DATE" == "$TODAY") || ("$LAST_BACKUP_DATE" == "$YESTERDAY") ]]; RESULT=$?
    if [[ $RESULT -ne 0 ]] ; then echo -e "***\n**\n*\n******************** WARNING --- last backup date was on $LAST_BACKUP_DATE ************\n*\n**\n***";
    else echo -e "\nOK: The last backup ($LAST_BACKUP_DATE) was made within the last 2 days.\n"; fi
}


function workarchive { # usage: cd /work/projects  then: "workarchive myproj-1234-rna-mouse"  --> will move things to bag_of_holding/work_archive/
    D=${1%/}
    DARCH=${D}_ARCHIVE
    TARGET=/bag_of_holding/work_archive/${D}
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD/Mac, so check for it
    echo "We would like to move the directory (without a slash) \"${D}\" to the final TAPE DRIVE target \"${TARGET}\"... sound ok to you? Select a NUMERIC option below:"
    select yn in "[Cancel]" "Move those files!"; do
	case $yn in
	    Move*) sudo mv ./${D} ./${DARCH}
		 ln -s ${TARGET} ./${D}
		 eval sudo ${AGW_IONICE} mv ./${DARCH}  ${TARGET}
		 break;;
	    *) echo "Ok, not doing anything."; break;;
	esac
    done
}

function mvln { # move and then make an ALIAS where the previous file was
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE filename (source) and ONE DESTINATION (probably a directory?) into this function!"; return; fi
    if [[ "$#" != 2 ]] ; then echo "[ERROR] Right now, this only works with TWO ARGUMENTS (target and destination)!"; return; fi
    agw_cmd_exists "ionice" && AGW_IONICE="ionice -c3" || AGW_IONICE="" # ionice doesn't exist on BSD/Mac, so check for it
    FILE=$1
    if [[ ! -e $FILE ]] ; then echo "[ERROR] Your source file ($FILE) does not exist!"; return; fi
    LAST=${@: -1}
    if [[ -d $LAST ]]; then # target is a directory
	LAST=${LAST%/} # remove trailing slash. This is OK even with '/' (root), since we always insert a slash at the end no matter what
	eval $AGW_IONICE mv "$FILE" "$LAST/"
	ln -s "$LAST/$FILE" "$FILE"
    else # target is a file
	eval $AGW_IONICE mv "$FILE" "$LAST"
	ln -s "$LAST" "$FILE"
    fi
}

function neararchive { # usage: cd /work/projects/your-project  then: "neararchive myproj-1234-rna-mouse"  --> will move things to the nearline storage and symlink them back
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE filename into this function!"; return; fi
    D=$(basename `pwd`)
    TARGET="/nearline_storage/castles_made_of_sand/not_backed_up/${D}"
    echo "We would like to move the following $# files to the NEARLINE SECONDARY STORAGE folder <${TARGET}/>... sound ok to you? Select a NUMERIC option below:"
    ls -1 -lh $@
    select yn in "[Cancel]" "Move those files!"; do
	case $yn in
	    Move*) mkdir -p "$TARGET"; for f in "$@"; do mv "$f" "${TARGET}/" && ln -s "${TARGET}/$f" ./ ; echo "Moved <$f> to <${TARGET}/$f>..." ; done; break;;
	    *) echo "Ok, not doing anything."; break;;
	esac
    done
}

function accuse { # See who is using the CPU. Usage: just "accuse" with no arguments
    USERS_WITH_JOBS=$(ps aux | tail -n +2 | cut -d ' ' -f 1 | uniq | sort -u)
    echo -e ">> Let's see who is using the CPU..."              >&2 # print to stderr
    echo -e ">> Going to check these users: ${USERS_WITH_JOBS}" >&2 # print to stderr
    TOPTEMP=$(mktemp) # Make a temp file
    TEMP2=$(mktemp)   # Make another temp file
    D=$(date '+%F %H:%M:%S')
    top -b -n 1 | tail -n +7 >> ${TOPTEMP} ;
    echo -e "USERNAME\t%CPU\tBARGRAPH\t# Date = \"${D}\"" >> ${TEMP2}
    NCPU=$(nproc)
    for u in $USERS_WITH_JOBS; do \
	cat $TOPTEMP | perl -e "my \$user = ${u}; my \$tot = 0; while(<>){ chomp; my @a=split(/\s+/); if (\$a[2] =~ m/${u}/i) {\$tot += \$a[9];}; } my \$stars = '|' . 'x' x (1+int((\$tot+50)/${NCPU})); print qq{\$user\t\$tot\t\$stars\n};"  >> ${TEMP2}; \
    done ;
    cat ${TEMP2} | column -t -s $'\t'
    /bin/rm ${TOPTEMP} ${TEMP2}
}

function giant { # find giant files
    #SAVED_IFS=$IFS; IFS=$(echo -en "\n\b")
    echo "Calculating all sizes first, then sorting them in ascending order..." >&2 # print to stderr
    DIRS="$@"
    sudo du -sc $DIRS | perl -nle 'print if not m/\btotal\b/' | perl -nle "@a = split(/\s+/); if (\$a[0]>0){print ((\$a[0]/1024.0/1024.0).qq{\t}.\$a[1]);} else { };" | sort -k1,1g | perl -e "my \$t = 0; while(<>) { my @a=split; \$t += \$a[0]; print join(qq{\t}, int(\$t/1024.0).qq{T}, int(\$a[0]).qq{G}, \$a[1]).qq{\n} }"
    #IFS=$SAVED_IFS
}


function giantpleb { # find giant files
    #SAVED_IFS=$IFS; IFS=$(echo -en "\n\b")
    echo "Calculating all sizes first, then sorting them in ascending order..." >&2 # print to stderr
    DIRS="$@"
    du -sc $DIRS | perl -nle 'print if not m/\btotal\b/' | perl -nle "@a = split(/\s+/); if (\$a[0]>0){print ((\$a[0]/1024.0/1024.0).qq{\t}.\$a[1]);} else { };" | sort -k1,1g | perl -e "my \$t = 0; while(<>) { my @a=split; \$t += \$a[0]; print join(qq{\t}, int(\$t/1024.0).qq{T}, int(\$a[0]).qq{G}, \$a[1]).qq{\n} }"
    #IFS=$SAVED_IFS
}



function wholog {
    echo "About to show who logs in and how big their home directories are..." >&2 # print to stderr
    TMP=$(mktemp)
    for f in $(cat /etc/passwd | cut -d ':' -f 1); do echo "Checking $f..." >&2 ; sudo lastlog -u $f; done | grep -v '^Username' | perl -pe 's/\s+/\t/' > $TMP
    sudo du -sch /home/* | perl -pe 's/\/home\///' | join.pl -o "NO_HOMEDIR" -1 1 -2 2 $TMP - | column -t -s $'\t'
}

function qing {
    echo "'qing' is 'qstats' but only showing NON-COMPLETED jobs..."
    echo "Note that 'qstat -f' may fail in cases where 'qstat' does not. Try plain 'qstat' if this command seems to be taking forever."
    echo "'qstat -f' has been known to take upwards of 2 minutes to run."
    qstats | grep -v ' COMPLETE '
    qstat -f -Q
}

function mypip {
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE PYTHON package-to-install into this function!"; return; fi
    echo "Installing the following python libraries: $@"
    echo "Installing into 'BINFPYROOT' environment variable at: $BINFPYROOT"
    pip2.7 install --ignore-installed --install-option="--prefix=$BINFPYROOT" $@
}

function mypylint {
    if [[ "$#" == 0 ]] ; then echo "[ERROR] You need to pass AT LEAST ONE PYTHON filename into this function!"; return; fi
    echo "Lintifying this file... $FILE"
    DISABLE_THESE_CHECKS="locally-disabled,global-variable-not-assigned,line-too-long,superfluous-parens,bad-whitespace,unused-wildcard-import,trailing-whitespace,unnecessary-pass,missing-docstring,invalid-name,global-statement,multiple-statements,too-many-locals,too-many-statements,too-many-branches,too-few-public-methods,too-many-lines,too-many-instance-attributes,too-many-arguments,wildcard-import,bad-continuation,unidiomatic-typecheck,expression-not-assigned,deprecated-lambda"
    pylint --jobs=4 --output-format=colorized --disable=$DISABLE_THESE_CHECKS "$@"
    # Best usage is: mypylint | s for viewing the colorized output!
}

function mycat { # cat2 / mycat
    # basically like 'cat' or 'zcat' but fancier
    # Based on file extension, turns something into plain text! Works on mixed files. Only delves one level of compression deep.
    for filename in "$@"; do # Loop through all the input arguments. Doesn't work with redirection.
	VC="cat" # This is the default
	filetype=$(file --dereference --brief "$filename")
	case "$filename" in
	    *.bam)  VC="samtools view -h " ; filetype="BAM_FILE_DETECTED_AGW";;
	esac
	case "$filetype" in 
	    gzip*)  VC="gzip  --decompress --stdout " ;; # zcat
	    bzip2*) VC="bzip2 --decompress --stdout " ;; # bzcat
	    [xX][zZ]*) VC="xz --decompress --stdout " ;; # xzcat
	esac
	$VC "$filename" # <-- actually decompress the file and print it to stdout
    done
}

alias tab="column -t -s $'\t'"

function brutallycompress {
    # Usage:    brutallycompress  DIRECTORY1   DIRECTORY2   DIRECTORY3
    # Recursively goes through and compresses (with gzip) any files with the extensions listed below.
    if [[ "$#" == 0 ]] ; then echo "[ERROR in arguments to brutallycompress] You need to pass AT LEAST ONE target directory into this function--it can also be '.' for the current directory!"; return; fi
    RESTRING=".*[._]\(wig\|bed\|_tracking\|diff\|bed.count\|moa\|fa\|fasta\|fq\|fastq\|txt\|csv\|tab\)"
    echo -e "# About to compress ($COMPRESS)\n#     anything in the following locations: $@\n#     that matches this REGULAR EXPRESSION: $RESTRING"
    echo -e "# -----------------------------------------------------------------------------------------------"
    for location in "$@"; do # Sanity check to make sure all inputs are DIRECTORIES to start
	if [[ ! -d "$location" ]] ; then echo "[ERROR in arguments to brutallycompress]: input '$location' was not a directory. Fix this--only give DIRECTORIES to 'brutallycompress'. Use '.' (not '*') if you want everything in the current directory!"; return 1; fi
    done
    for location in "$@"; do # Loop through all the input arguments. Doesn't work with redirection.
	if [[ ! -d "$location" ]] ; then echo "[ERROR]: input '$location' was not a directory!"; return 1; fi
	find "$location" -type f -regex "$RESTRING" -print0 | xargs -0 -I {} sh -c "echo 'Compressing' '{}'; gzip --verbose -6 '{}';" # <-- do **NOT** put double quotes around $COMPRESS (no "")
	#find "$location" -type f \( -iname "*.bed" -o -iname "*_tracking" -o -iname "*.diff" -o -iname "*.bed.count" -o -iname "*.moa" -o -iname "*.fa" -o -iname "*.fq" -o -iname "*.fasta" -o -iname "*.fastq" -o -iname "*.txt" \) -print0 | xargs -0 $COMPRESS
    done #  xargs -I %%% sh -c 'echo %%%; echo %%%;'
}

function rtag {
    # Recursively set finder tags
    tag=$1
    shift
    for fff in "$@"; do # Loop through all the input arguments. Doesn't work with redirection.
	#find . -exec tag --add tagname {} \;  -print
	#find $name -type f | xargs xattr -wx com.apple.FinderInfo "`xattr -px sampleFile`"
	echo "Adding tag $tag to $fff"
    done
}

function wgetdevour { # wget devour
    if [[ "$#" != "3" ]] ; then echo "[ERROR] You need to pass THREE arguments -- username, password, directory!"; return; fi
    USERNAME=$1
    PASSWORD=$2
    DIRECTORY=$3
    wget -mk -r -U mozilla --connect-timeout=90 --random-wait -e robots=off --limit-rate=1m --tries=99 --timeout=50 \
	 -A md5,fasta,fa,fastq,fq,bz2,gz,Z,gzip,bzip2,pdf,xls,xlsx,bed,sam,bam,vcf,csv,txt,sh,complete \
	 --no-parent \
	 --http-user="$USERNAME" --http-passwd="$PASSWORD" "$DIRECTORY/" # trailing slash here is crucial
}

function truename {
    qsub -I  -l ncpus=1  -l mem=4gb  -l walltime=24:00:00 -N "INTERACTIVE_for_$USER" -q Interactive -W group_list="interactive"
}

function qsud {
    if [[ "$#" == "0" ]] ; then echo "[ERROR] qq (queue submission) needs at least ONE argument script!"; return; fi
    PBS_BIO_GGG="Bio"
    PBS_BIO_QQQ="bioqueue"
    PBS_GEN_GGG="General"
    PBS_GEN_QQQ="genqueue"
    groupstr=`groups`
    case "$groupstr" in 
	*bioqueue*)
    	    QGRP="$PBS_BIO_GGG"
	    QQUE="$PBS_BIO_QQQ"
	    ;;
	*genqueue*)
    	    QGRP="$PBS_GEN_GGG"
	    QQUE="$PBS_GEN_QQQ"
	    ;;
	*)
    	    echo "[ERROR] your username was not in a relevant group -- it must be in either the 'bioqueue' or 'genqueue' groups. This is MANDATORY if qsud is to work!"
	    return 99
	    ;;
    esac
    cmd=( "qsub" "-q" $QGRP "-V" "-l walltime=320:59:59" "-W group_list=\"$QQUE\"" "$@" ) # 14 days is the longest possible
    echo -e "About to execute this command. Note that all paths must be FULL PATHS:\n----------\nCOMMAND>      ${cmd[@]}\n----------"
    "${cmd[@]}" # <- Actually execute. See http://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
}

function hist {
    history | tail -n 100
}

# ================ QUEUE / QSUB LOG VIEWING AND MOVING ================
function rmlogs { # Usage:     catlogs (no arguments)
    NUM_FOUND=$(find . -maxdepth 1  -type f  -regex '.*[.][eo][0-9]+' | wc -l)
    echo "Deleting $NUM_FOUND 'qsub' logs (the files ending with .e1234 or .o456, etc.)..."
    find . -maxdepth 1  -type f  -regex '.*[.][eo][0-9]+' -delete
    echo "[Done] Deleted the $NUM_FOUND log files.."
}
function catlogs { # Usage:     catlogs (no arguments)
    echo "Concatenating all the QSUB logs in this directory into one file, which we will then view with 'less'"
    #cat *.[eo][0-9][0-9]* | s
    find . -maxdepth 1  -type f  -regex '.*[.][eo][0-9]+' -print0 | xargs -0 -I{} paste.pl "FILE={}" {} | s
    #find . -maxdepth 1 -type f -exec paste.pl "FILE={}" {} \; | s
}
function mvlogs { # Usage:   mvlogs OUTPUT_DIRECTORY
    # This function moves those annoying qzub logs to the destination directory
    if [[ "$#" == "0" ]] ; then echo "[ERROR] mvlogs needs a destination directory!"; return; fi
    if [[ ! -d $1 ]] ; then echo "[ERROR] mvlogs needs an EXISTING DIRECTORY as a destination! The specified directory ($1) appears not to exist."; return; fi
    find . -maxdepth 1  -type f  -regex '.*[.][eo][0-9]+' -print0 | xargs -0 -I{} mv {} $1/
    echo "[OK] Moved all the logs into the directory $1"
}
# ========================================================

function refresh { # Usage:  refresh (no arguments)
    FAKEFILE=$(mktemp ./tmp.XXXXXX.tmp) ; /bin/rm $FAKEFILE;
    (>&2 echo "Refreshing the filesystem, which is important since the NFS system otherwise takes 60 seconds to update...")
}

function star_make_index {
    # This makes an alignment directory for the "STAR" aligner, when given just a fasta file and a length.
    # The exact length is not critical, but it should ideally be the same length as the reads, if possible (slightly longer is OK too, but not necessary).
    if [[ "$#" != "2" ]] ; then echo "[ERROR] star_make_index needs an input FASTA file and a 'how long are the reads' parameter!"; return; fi
    FAS=$1
    LEN=$2
    CPU_THREADS=6
    if ! [[ ${FAS^^} =~ \.*[.](FASTA|FA)$ ]]; then echo "Arg1 must be .fasta or .fa file, but it was: $FAS"; return 1; fi
    if ! [[ ${LEN^^} =~ ^[0-9]+$ ]]; then echo "Arg2 must be a (numeric integer) read length, but it was: $LEN"; return 1; fi
    OUT=$(basename $FAS | perl -pe 's/[.](fasta|fa)$//i')
    OUT=$(echo `pwd`/star_output.$OUT)
    (>&2 echo "Output file is:  " $OUT)
    (>&2 echo "About to generate a STAR genome index. Settings are as follows:")
    (>&2 echo "        FASTA: $FAS")
    (>&2 echo "       LENGTH: $LEN")
    (>&2 echo "   OUTPUT DIR: $OUT")
    (>&2 echo "       N CPUS: $CPU_THREADS")
    cmd="mkdir -p $OUT && STAR --runMode genomeGenerate --genomeDir $OUT --genomeFastaFiles $FAS --runThreadN $CPU_THREADS"
    (>&2 echo -e "Here is the command you should now run:\n   $cmd\n   (Copy and paste that command above, or run it with 'qplz' and double quotes: qplz -t $CPU_THREADS -m 8 \"command\""  )
}

function convert_chromosome_to_chr1_for_genome_browser {
    if [[ "$#" != "2" ]] ; then echo "[ERROR] needs two inputs: 1. a chromosome to turn into 'chr1' and 2. a bam filename to convert"; return; fi
    FINDCHR=$1
    IN=$2
    NEWCHR=chr1
    TMPSAM=${IN}--TMP.sam
    if [[ ! -e $IN ]] ; then echo "[ERROR] Your specified input file ($FILE) does not exist!"; return; fi

    FINALBAM=${IN/.bam/--${NEWCHR}_only.bam}

    (>&2 echo "[CONVERSION UPDATE] Fixing the @SQ lines at the top of the file...")
    samtools view -H $IN | perl -ne "print if (not m/^[@]SQ/ or s/^([@]SQ.*SN:)$FINDCHR(\s)/\$1$NEWCHR\$2/)" >| $TMPSAM
    samtools view    $IN \
	| awk "\$3==\"$FINDCHR\" {print;}" \
	| awk -v OFS='\t' "{\$3=\"$NEWCHR\";print;}" \
	| cat $TMPSAM - \
	| samtools view -b -S - \
	>| $FINALBAM
    /bin/rm $TMPSAM

    (>&2 echo "<$FINALBAM> generated! Chromosome changed from '$FINDCHR' to 'chr1'. Original input: <$IN>")
}

function pdf2png {
    for f in "$@" ; do echo "Converting $f..."; convert -verbose -density 72 $f +antialias ${f/.pdf}.png; done
}

function redrop {
    dropbox.py stop && dropbox.py start && sleep 2 && dropbox.py status;
}

function aws_ls_fastq {
    if [[ -z ${EPI_S3_FASTQ_SEQ_BUCKET+x} ]]; then echo "EPI_S3_FASTQ_SEQ_BUCKET is unset! Set it in the .local-config-no-git file."; exit 1; fi
    # Note that the buckets are defined in .local-config-no-git
    (>&2 echo "Performing the equivalent of an 'ls -1' on the sequencing data bucket. You probably want to redirect this to a text file.")
    aws s3 ls s3://${EPI_S3_FASTQ_SEQ_BUCKET}/Fastq_Files_per_run/ --recursive | awk '{print $4 }'
    (>^2 echo "[Done] listing the directory on ${EPI_S3_FASTQ_SEQ_BUCKET}!")
}

function pybug {
    #echo "$1"       # First argument
    #echo "2 ${@:2}" # Arguments 2 and beyond
    if [[ ! -e "$1" ]]; then
	echo "Looks like your (required!) python script <$1> could not be found!"
	exit
    fi
    echo "Running [ipython]..."
    ipython --pdb "$1"         -- "${@:2}"
    #             SCRIPT NAME     ARGUMENTS
}

function docker-begone {
    echo "Stopping and removing ALL DOCKER CONTAINERS. ALL OF THEM!"
    docker stop $(docker ps -a -q)
    docker rm $(docker ps -a -q)
    echo "Not even one docker container was spared."
    echo "Clearing out space also..."
    docker rm $(docker ps -q -f 'status=exited')
    echo "You may also have to, with RUNNING YOUR CONTAINERS, run this: docker system prune -a"
    echo "The file that should be small now is:"
    ls -lah $HOME/Library/Containers/com.docker.docker/Data/com.docker.driver.*/*.qcow2
    echo "Clearing out space for any 'dangling' docker items (probably there are none)..."
    docker rmi $(docker images -q -f "dangling=true")
    
}

# count bases per line in a fasta file:
# cat x.fa | grep -v '^>' | perl -ne 'chomp; my @a=split(//,$_); my %c=(); for my $x (@a) { $c{lc($x)}++; }; for my $k (keys(%c)) { print($k.qq{=}.$c{$k}."\t"); }; print qq{  <-- \n};'

