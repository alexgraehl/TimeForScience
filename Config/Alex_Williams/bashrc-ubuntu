# -*-Sh-*- <-- tells emacs what kind of syntax highlighting to use

[[ -z "$PS1" ]] && return # <-- If not running interactively, don't
# do anything. Printing any output breaks ssh and various things.
# This is why this line is important at the very top!

# .bashrc: Loaded when the shell is non-interactively started up

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# Set up things below ONLY if this shell is interactive

if [[ -f ~/TimeForScience/Config/Alex_Williams/bash-platform-specific ]] ; then
    source ~/TimeForScience/Config/Alex_Williams/bash-platform-specific
fi

echo -e "${a_echo_color}>>> BASH: Loading .bashrc...${a_end_color}"

if [[ -f ~/TimeForScience/Config/Alex_Williams/bash-path-setup ]] ; then
    source ~/TimeForScience/Config/Alex_Williams/bash-path-setup
fi

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.
# Sets up the aliases whether or not this shell is interactive
if [[ -f ~/TimeForScience/Config/Alex_Williams/bash-aliases ]]; then
    source ~/TimeForScience/Config/Alex_Williams/bash-aliases
fi


#iterm_bg=000000
#iterm_title_r255=200
#iterm_title_g255=0
#iterm_title_b255=0

# ======== SET THE COMMAND PROMPT COLOR FOR THIS MACHINE ======== #
a_machine_prompt_main_color=''
if [[ -n "$color_prompt" ]] ; then
    if [[ -z "$is_sshing" ]] ; then
	## LOCAL machine gets a specific color...
	#a_machine_prompt_main_color="$color_prefix[44m$color_prefix[3;33m" ## Blue background, white foreground
	a_machine_prompt_main_color="${color_prefix}[1;32m" ## Bold green text
	##[[ $TERM_PROGRAM == iTerm ]] && 
	#iterm_bg=001100 # iTerm console window background
    else
	## Ok, we are SSHed into a remote machine...
	case "$HOSTNAME"
	    in
	    nausicaa)
		a_machine_prompt_main_color="${color_prefix}[1;35m" ; ## 1;35m == Bold magenta
		iterm_bg=001100 ;# iTerm console window background
		;;
	    catbus)
		a_machine_prompt_main_color="${color_prefix}[1;34m"
		iterm_bg=000022 ;# iTerm console window background
		;;
	    bueno)
		a_machine_prompt_main_color="${color_prefix}[44m${color_prefix}[3;36m" # cyan text / blue background
		iterm_bg=220000 ;# iTerm console window background
		;;
	    lighthouse)
		a_machine_prompt_main_color="${color_prefix}[43m${color_prefix}[3;30m" # yellow background
		iterm_bg=222200 ;# iTerm console window background
		;;
	    --)
		a_machine_prompt_main_color="${color_prefix}[41m${color_prefix}[3;37m"
		iterm_bg=220022 ;# iTerm console window background
		;;
	esac
    fi

    #\033[47m\033[3;31m   ## <-- For the second part, where it says [3;31m 1=bold, 2=light, 3=regular
fi
# ======== SET THE COMMAND PROMPT COLOR FOR THIS MACHINE ======== #


#echo -e "\033]Pg4040ff\033\\"
[[ -n "$iterm_bg" ]] && echo -e "\033]Ph${iterm_bg}\033\\" ; ## iTerm background
if [[ -n "$iterm_title_r255" ]] ; then
    echo -e "\033]6;1;bg;red;brightness;${iterm_title_r255}\a" ; ## title bar of iTerm
    echo -e "\033]6;1;bg;green;brightness;${iterm_title_g255}\a" ; ## title bar of iTerm
    echo -e "\033]6;1;bg;blue;brightness;${iterm_title_b255}\a" ## title bar of iTerm
fi


if [[ -z "$STY" ]] && [[ "$HOSTNAME" == 'nausicaa' ]] ; then
    echo -e "${a_warning_color}*\n*\n* Remember to resume the screen session on this machine!!!\n*\n*${a_end_color}"
else
    echo -n ''
fi

## ===============================================
## ====== TERMINAL HISTORY =======================
export HISTSIZE=9999
export HISTCONTROL=ignoreboth  # duplicate and blank lines are not saved in the history
shopt -s histappend # Save terminal history between sessions
PROMPT_COMMAND='history -a' ## save ALL terminal histories
## ====== TERMINAL HISTORY =======================
## ===============================================

set   -o ignoreeof  # Prevent Ctrl-D from exiting!
shopt -s checkwinsize # Check the window size after each command and, if necessary, update the values of LINES and COLUMNS.
shopt -s cdspell ## Fix common mis-spellings in directories to "cd" to
shopt -s cmdhist ## Save multi-line pasted commands into one single history command
#shopt -s lithist ##
shopt -s no_empty_cmd_completion ## Don't display ALL commands on an empty-line tab
shopt -s nocaseglob ## Match glob / regexp in case-insensitive fashion

# set variable identifying the chroot you work in (used in the prompt below)
if [[ -z $debian_chroot ]] && [[ -r /etc/debian_chroot ]]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi


if [[ $color_prompt -eq 1 ]]; then
    PS1="\[${a_machine_prompt_main_color}\][\$(date +%H:%M)] [\u@\h:\W]\$\[\033[0m\]\[${a_end_color}\] "
else
    PS1="[\$(date +%H:%M)] [\u@\h:\W]\$ "
fi

# enable color support of ls and also add handy aliases
if [[ -x /usr/bin/dircolors ]]; then
    eval "`dircolors -b`"
    #alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    #alias grep='grep --color=auto'
    #alias fgrep='fgrep --color=auto'
    #alias egrep='egrep --color=auto'
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [[ -f /etc/bash_completion ]]; then
    . /etc/bash_completion
fi


## ===============================================
## ====== LS COLORS ==============================
## COMMAND LINE COLOR / LS COLOR
export CLICOLOR='Yes'
export LS_OPTIONS='--color=auto'
## LS_COLORS *with* an underscore is for Ubuntu
export LS_COLORS='no=00:fi=00:di=01;35:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;31' 
## LSCOLORS *without* an underscore is for Mac OS X
export LSCOLORS=FxgxCxDxBxegedabagacad
#if [[ -n "$isMac" ]] ; then
#    AGW_LS_COLOR_OPTION=" -G "  ## -G means "color" on the mac...
#else
#    AGW_LS_COLOR_OPTION=' --color=auto ' 
#fi
## ====== LS COLORS ==============================
## ===============================================

export CVS_RSH=ssh
export CVSEDITOR="emacs -nw"
export SVN_EDITOR="emacs -nw"
export EDITOR="emacs -nw"



HISTSIZE=10000
HISTCONTROL=ignoreboth
# this causes any lines matching the previous history entry not to be saved.

# Keybindings: Add IJKL navigation to supplement/replace the arrow keys
bind "\M-J:backward-word"
bind "\M-L:forward-word"
bind "\M-j:backward-char"
bind "\M-l:forward-char"
bind "\M-i:previous-history"
bind "\M-I:previous-history"
bind "\M-k:next-history"
bind "\M-K:next-history"
bind "\C-s:history-search-forward"

# Save the local ethernet "en0" MAC address into the variable LOCAL_EN0_MAC. Note the zero.
# Allows per-machine settinsg.
#export LOCAL_EN0_MAC=`ifconfig en0 | grep -i ether | sed 's/.*ether //' | sed 's/[ ]*$//'`

umask 0007 # <-- give users and groups full access to files I create, but give no access to other users.
# 0 = "full access", 7 = "no access"


function n {
    echo -e  "$color_prefix[30m black $color_prefix[31mred $color_prefix[32mgreen $color_prefix[33myellow $color_prefix[34mblue $color_prefix[35mmagenta $color_prefix[36mcyan $color_prefix[37mwhite"
}

function zzz {
    echo -e "${a_echo_color}>>> BASH: Loading .bashrc...${a_end_color}"
}

# Add IJKL navigation to supplement/replace the arrow keys
bind "\M-J:backward-word"
bind "\M-L:forward-word"
bind "\M-j:backward-char"
bind "\M-l:forward-char"

bind "\M-i:previous-history"
bind "\M-I:previous-history"

bind "\M-k:next-history"
bind "\M-K:next-history"

bind "\C-s:history-search-forward"

# =======
