# -*-Sh-*- <-- tells emacs what kind of syntax highlighting to use

# .bashrc: Loaded when the shell is non-interactively started up

# [ -z "$PS1" ] && return <-- If not running interactively, don't do anything
# Printing any output breaks ssh and various things. This is why this line is important at the very top!
[ -z "$PS1" ] && return

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# Set up the path whether or not this shell is interactive


if [ -f ~/TimeForScience/Config/Alex_Williams/bash-platform-specific ] ; then
    source ~/TimeForScience/Config/Alex_Williams/bash-platform-specific
fi

echo -e "${a_echo_color}>>> BASH: Loading .bashrc...${a_end_color}"

if [ -f ~/TimeForScience/Config/Alex_Williams/bash-path-setup ] ; then
    source ~/TimeForScience/Config/Alex_Williams/bash-path-setup
fi



# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.
# Sets up the aliases whether or not this shell is interactive
if [ -f ~/TimeForScience/Config/Alex_Williams/bash-aliases ]; then
    source ~/TimeForScience/Config/Alex_Williams/bash-aliases
fi

if [[ -z $STY && $HOSTNAME = 'nausicaa' ]] ; then
    echo -e "${a_warning_color}*\n*\n* Remember to resume the screen session on this machine!!!\n*\n*${a_end_color}"
else
    echo -n ""
fi




# don't put duplicate lines in the history. See bash(1) for more options
# don't overwrite GNU Midnight Commander's setting of `ignorespace'.
export HISTSIZE=9999
export HISTCONTROL=$HISTCONTROL${HISTCONTROL+,}ignoredups
# ... or force ignoredups and ignorespace
export HISTCONTROL=ignoreboth  # this causes any lines matching the previous history entry not to be saved.

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi


if [ "$color_prompt" -eq 1 ]; then
    #PS1="${a_machine_prompt_main_color}\u@\h:\w\$${a_end_color}" #"${debian_chroot:+($debian_chroot)}\[$color_prefix[01;32m\]\u@\h\[$color_prefix[00m\]:\[$color_prefix[01;34m\]\w\[$color_prefix[00m\]\$ "
    #PS1="\u@\h:\w\$"
## \w is the full working directory
## \W is just the basename of the working directory
    PS1="\[${a_machine_prompt_main_color}\][\$(date +%H:%M)] [\u@\h:\W]\$\[\033[0m\]\[${a_end_color}\] "
    #PS1="\[\033[1;34m\][\$(date +%H:%M)][\u@\h:\w]$\[\033[0m\] "
    #PS1="${debian_chroot:+($debian_chroot)}\[$color_prefix[01;32m\]\u@\h\[$color_prefix[00m\]:\[$color_prefix[01;34m\]\w\[$color_prefix[00m\]\$ "
else
    PS1="${debian_chroot:+($debian_chroot)}\u@\h:\w\$ "
fi
unset color_prompt ## done with this variable...

# If this is an xterm set the title to user@host:dir
case "$TERM" in
    xterm*|rxvt*)
	## Set the title text!
	PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
	;;
    *)
	;;
esac


# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    eval "`dircolors -b`"
    #alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    #alias grep='grep --color=auto'
    #alias fgrep='fgrep --color=auto'
    #alias egrep='egrep --color=auto'
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi




#export LSCOLORS='no=00:fi=00:di=01;35:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;31'
export LSCOLORS=FxgxCxDxBxegedabagacad
#The order of the attributes for LSCOLORS is as follows:
#
#    1.   directory
#    2.   symbolic link
#    3.   socket
#    4.   pipe
#    5.   executable
#    6.   block special
#    7.   character special
#    8.   executable with setuid bit set
#    9.   executable with setgid bit set
#    10.  directory writable to others--with sticky bit
#    11.  directory writable to others--no sticky bit
#:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:'

#export CVSROOT=:ext:alexgw@hoot.cse.ucsc.edu:/cse/grads/cchen/cvsroot
export CVSROOT=:ext:alexgw@tap.cse.ucsc.edu:/projects/compbio/cvsroot/stuartlab
export CVS_RSH=ssh
export CVSEDITOR="emacs -nw"
export SVN_EDITOR="emacs -nw"

export PAGER=less
export EDITOR="emacs -nw"
export TERM=xterm-color
#256color



set -o ignoreeof  # Prevent Ctrl-D from exiting!

HISTSIZE=10000
HISTCONTROL=ignoreboth
# this causes any lines matching the previous history entry not to be saved.

# Keybindings
# Add IJKL navigation to supplement/replace the arrow keys
bind "\M-J:backward-word"
bind "\M-L:forward-word"
bind "\M-j:backward-char"
bind "\M-l:forward-char"
bind "\M-i:previous-history"
bind "\M-I:previous-history"
bind "\M-k:next-history"
bind "\M-K:next-history"
bind "\C-s:history-search-forward"




# Save the local ethernet "en0" MAC address into the variable LOCAL_EN0_MAC. Note the zero.
# Allows per-machine settinsg.
#export LOCAL_EN0_MAC=`ifconfig en0 | grep -i ether | sed 's/.*ether //' | sed 's/[ ]*$//'`



umask 0007 # <-- give users and groups full access to 
# files I create, but give no access to other users.
# 0 = "full access", 7 = "no access"


function n {
    echo -e  "$color_prefix[30m black $color_prefix[31mred $color_prefix[32mgreen $color_prefix[33myellow $color_prefix[34mblue $color_prefix[35mmagenta $color_prefix[36mcyan $color_prefix[37mwhite"
}

function zzz {
    echo -e "${a_echo_color}>>> BASH: Loading .bashrc...${a_end_color}"
}

# 30 through 37 are the FOREGROUND
# 40 through 47 are the BACKGROUND
# The order of colors is BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE
# echo -e '$color_prefix[30m black $color_prefix[31mred $color_prefix[32mgreen $color_prefix[33myellow $color_prefix[34mblue $color_prefix[35mmagenta $color_prefix[36mcyan $color_prefix[37mwhite'
# echo -e '$color_prefix[30;41mblack on red'




# Add IJKL navigation to supplement/replace the arrow keys
bind "\M-J:backward-word"
bind "\M-L:forward-word"
bind "\M-j:backward-char"
bind "\M-l:forward-char"

bind "\M-i:previous-history"
bind "\M-I:previous-history"

bind "\M-k:next-history"
bind "\M-K:next-history"

bind "\C-s:history-search-forward"





#export TERM=xterm-color
#export CVSROOT=:ext:alexgw@tap.cse.ucsc.edu:/projects/compbio/cvsroot/stuartlab




#export LSCOLORS='no=00:fi=00:di=01;35:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;31'
#export LSCOLORS=FxgxCxDxBxegedabagacad
#The order of the attributes for LSCOLORS is as follows:
#
#                           1.   directory
#                           2.   symbolic link
#                           3.   socket
#                           4.   pipe
#                           5.   executable
#                           6.   block special
#                           7.   character special
#                           8.   executable with setuid bit set
#                           9.   executable with setgid bit set
#                           10.  directory writable to others, with sticky bit
#                           11.  directory writable to others, without sticky
#                                bit
#:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:'





# echo -e "\\e[0mCOLOR_NC (No color)"
# echo -e "\\e[1;37mCOLOR_WHITE\\t\\e[0;30mCOLOR_BLACK"
# echo -e "\\e[0;34mCOLOR_BLUE\\t\\e[1;34mCOLOR_LIGHT_BLUE"
# echo -e "\\e[0;32mCOLOR_GREEN\\t\\e[1;32mCOLOR_LIGHT_GREEN"
# echo -e "\\e[0;36mCOLOR_CYAN\\t\\e[1;36mCOLOR_LIGHT_CYAN"
# echo -e "\\e[0;31mCOLOR_RED\\t\\e[1;31mCOLOR_LIGHT_RED"
# echo -e "\\e[0;35mCOLOR_PURPLE\\t\\e[1;35mCOLOR_LIGHT_PURPLE"
# echo -e "\\e[0;33mCOLOR_YELLOW\\t\\e[1;33mCOLOR_LIGHT_YELLOW"
# echo -e "\\e[1;30mCOLOR_GRAY\\t\\e[0;37mCOLOR_LIGHT_GRAY"



## Below: aliases the command "rm" to actually run the script "trash.pl," which moves files to a trash directory in /tmp.
## They can be recovered by just copying them back.
## Use the "checktrash" command to find the trash directory if you forget where it is.
#alias rm='/home/alexgw/trash.pl'

## Below: the REAL rm command in /bin/rm is aliased to "rrm". rrm will delete files instantly.
## You may need to use this in the few cases where trash.pl doesn't work, like for files with unusual special characters.
alias rrm='/bin/rm'

## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'


## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'


## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'


## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'


## Below: aliases the command "rm" to actually run the script "trash.pl," which moves files to a trash directory in /tmp.
## They can be recovered by just copying them back.
## Use the "checktrash" command to find the trash directory if you forget where it is.
alias rm='/home/alexgw/trash.pl'

## Below: the REAL rm command in /bin/rm is aliased to "rrm". rrm will delete files instantly.
## You may need to use this in the few cases where trash.pl doesn't work, like for files with unusual special characters.
alias rrm='/bin/rm'

## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'


## Below: aliases the command "rm" to actually run the script "trash.pl," which moves files to a trash directory in /tmp.
## They can be recovered by just copying them back.
## Use the "checktrash" command to find the trash directory if you forget where it is.
alias rm='/home/alexgw/trash.pl'

## Below: the REAL rm command in /bin/rm is aliased to "rrm". rrm will delete files instantly.
## You may need to use this in the few cases where trash.pl doesn't work, like for files with unusual special characters.
alias rrm='/bin/rm'

## Below: the command to list the top-level contents of the trash directory. You may have to look through the files here if you want to recover something you just accidentally deleted. Beware, files don't last long in /tmp\!
alias checktrash='mkdir -p /tmp/${USER}/Trash/ && echo "Contents of /tmp/${USER}/Trash:" && ls /tmp/${USER}/Trash/'

