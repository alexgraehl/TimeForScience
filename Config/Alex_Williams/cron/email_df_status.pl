#!/usr/bin/perl

## Note the plaintext password here!

use strict;
use warnings;

my $dfTemp = '/tmp/df.tmp';
my $sendTo = 'alexgraehl+lighthouse+status+update@gmail.com';

my $EMAIL_USERNAME_FROM = 'binfcore'; ## Do NOT include @gmail.com here!

my $email_smtp_client_location = $ARGV[0];
my $PLAINTEXT_PASSWORD = $ARGV[1];

if (!defined($email_smtp_client_location)) {
    print STDERR "Not enough arguments to email_df_status.pl: Need to specify executable for SMTP sending (first argument! type which email-smtp-client.pl)...\n";
    exit(1);
}

if (!defined($PLAINTEXT_PASSWORD)) {
    print STDERR "Not enough arguments to email_df_status.pl: Need to define the password (second argument!)...\n";
    exit(1);
}

my $HOSTNAME = `hostname`; # or uname-n
$HOSTNAME =~ s/^\s+//; $HOSTNAME =~ s/\s+$//; # remove trailing spaces, and then remove leading spaces

system(qq{echo 'Automatic status report from $HOSTNAME' > $dfTemp});

my $UPTIME = `uptime`;
system(qq{echo 'Auto server report from $HOSTNAME' > $dfTemp});
system(qq{echo 'Generated by the script <email_df_status.pl>, which is set in the crontab (you can edit it with the following command: "crontab -u ${USER} -e")' > $dfTemp});
system(qq{echo 'Uptime report: $UPTIME' >> $dfTemp});
system(qq{df >> $dfTemp}); ## save the df output to a file
system(qq{ perl \"$email_smtp_client_location\" } ## it's written in perl, so we can run it that way
       . qq{ --host=smtp.gmail.com }
       . qq{ --port=587 }
       . qq{ --user=$EMAIL_USERNAME_FROM }
       . qq{ --pass=$PLAINTEXT_PASSWORD }
       . qq{ --to=$sendTo }
       . qq{ --subject="DF output for $HOSTNAME, automatically sent by a cron job" }
       . qq{ --body-plain=$dfTemp }
    );


